<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[跨链的技术实现研究]]></title>
      <url>/2020/02/28/%E8%B7%A8%E9%93%BE%E7%9A%84%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E7%A0%94%E7%A9%B6/</url>
      <content type="html"><![CDATA[<h1 id="跨链的技术实现研究">跨链的技术实现研究</h1><p>创建时间：2020年2月28日<br>更新时间：2020年2月28日<br>作者：ShizhiDeng<br>更新内容：</p>
<ul>
<li><p>2020-02-28 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 总结区块链扩容的三种方法：代议制、分层和分片，分片的四个难题和解决方案</span><br><span class="line">2. 区块链领域待解决的问题 Scalability Isolatability Developability  Governance  Applicability</span><br><span class="line">3. 区块链领域待解决问题的解决方案：一致性(canonicality)和有效性(validity)的分离</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="区块链的扩容方案^_1">区块链的扩容方案<a href="https://www.polkaworld.org/articles/mo-zi-chang-wen-shuo-tou-polkadotjia-gou-shang" target="_blank" rel="noopener">^ 1 </a></h2><ul>
<li>问题描述：区块链扩容问题，指的是能不能把 DApp 和中心化互联网应用的成本差距，从 100 万倍拉近到 10 万倍，1 万倍，甚至 1 千倍。同时仍然保持去信任、无许可和抗审查这三大好处。</li>
<li><p>答案：方法有三类，也就是区块链扩容的三个思路——代议制、分层和分片</p>
<ul>
<li>第一个扩容思路——代议制<ul>
<li>原理：代议制是人民选出代表，再由代表来议定法律或者重大决议。代议制提升决策效率有两个原因，第一是参与共识的人数大为减少，第二是代表通常是专职政治家，他们有更多的资源和知识来议定国家大事。</li>
<li>采用代议制的区块链：用代议制的方式来做区块链扩容，最典型的是采用 DPoS 共识的 EOS。EOS 通证的持有者选出超级节点，21 个超级节点轮流出块。跟以太坊相比，参与共识的计算机数量下降了 3 个数量级。</li>
<li>如果把是大部分身家都用加密货币来做长期价值存储，我首选比特币。如果是小额支付，或者打麻将、掷骰子，用 EOS 当然也没问题。在区块链世界，从去中心化程度最高的比特币和以太坊，到中心化程度最低的 EOS 和波场。</li>
</ul>
</li>
<li>第二种扩容思路 —— 分层<ul>
<li>原理：分层也称为二层扩容或者链下扩容，就是把一部分交易放到在区块链以外执行，同时仍然保障交易安全。</li>
<li>技术划分：分层有状态通道和侧链（实现层面很类似）两类技术。还有一类二层技术，是把计算密集型任务转移到链下执行。</li>
<li>侧链技术<ul>
<li>SPV 是 Simplified Payment Verification 简单支付验证的缩写。为了让计算和存储能力有限的设备能够使用比特币的问题，才有了 SPV，或者叫轻客户端或者轻节点。（比如：手机钱包就是轻节点，使用了Merkle树）</li>
<li>侧链方案就是把主链资产通证锁定，在侧链上对应地创造出通证承兑汇票，汇票交易在侧链执行，在侧链上得到汇票的人可以兑换主链通证。</li>
<li>举例：以太坊 Plasma MVP 侧链方案，注意侧链本也是区块链，它有自己的共识协议和矿工，侧链采用的共识是 PoA 权威证明，就是一个 Operator 说了算，由它记账出块。PoA 当然不是唯一选择，Loom 的 Plasma 侧链采用的 DPoS 共识。侧链区块的区块头，都会由 Operator 提交给主链的 Plasma 合约。不论侧链一个区块含有多少笔交易，是 1 千笔还是 1 万笔，主链只发生了记录区块头一笔交易。所以主链上的 Plasma 合约，相当于是侧链的 SPV 轻节点，它存储了区块头，从而可以验证侧链交易是否存在。</li>
</ul>
</li>
</ul>
</li>
<li>第三种扩容思路 —— 分片<ul>
<li>原理：别让所有的节点都执行所有的交易。把节点分成很多组，或者说分成很多片。多个分片可以并行处理交易，总体的处理能力就提高了。当然还需要一条特殊的链来看管所有的分片，这条一般称之为主链。</li>
<li>分片扩容的基本思路非常简单，但实际做起来则面临很多复杂难题。<ul>
<li>难题1:验证人选择。</li>
<li>难题1的解决方案：验证人随机动态分组。<ul>
<li>解决的方法是，分片的验证人分组不是固定的，而是随机选取，而且每隔一段时间就重新分组。这样恶意的验证人不能事先知道自己被分到哪个组，而贸然发送攻击会受到惩罚，因此系统的安全性就不会随着分片数量上升线性的下降。</li>
<li>验证者随机动态分组的关键，是要有可靠的随机数，随机数一直是计算机科学中复杂而有趣的问题。去中心化地拜占庭容错地产生可靠随机数难度非常大，也是区块链研究的热点问题。</li>
</ul>
</li>
<li>难题2:跨片交易完整性。</li>
<li>难题2的解决方案：概率最终性==&gt;明确最终性。<ul>
<li>分布式交易的完整性或者原子性：一个跨链交易要引起两条链乃至多条链的状态改变，而且这些改变要么都成功，要么都不成功，不存在中间状态。这跟企业计算里分布式交易的概念上非常类似。比如：从建行转账1万到农行，建行减去1万，农行增加1万，同时成功或者同时失败。</li>
<li>这个问题在区块链中的复杂性：没有明确最终性（finality），就是交易打包到区块，有可能回滚，就是撤销。</li>
<li>解决方法：要有机制让区块具有明确的最终性，不能含糊。</li>
</ul>
</li>
<li>难题3：最终性 VS 活性</li>
<li>难题3的解决方案：混合共识：出块和敲定（finalize）分开。<ul>
<li>finalize 就是使区块具有最终性；liveness：出块停止了，或者说区块链丧失了活性 liveness。</li>
<li>例如：Cosmos 的 Tentermint 共识，以太坊 2.0 和 Polkadot。</li>
<li>解决方法：混合共识。节点可以继续出块，但没有足够的验证人，不能敲定，等达到条件再敲定。混合共识可以让个别节点轮番速度出块，敲定过程可以慢点。</li>
</ul>
</li>
<li>难题4:交易有效性<ul>
<li>交易有效性问题就是防止无效交易进入区块，成为区块链维护的历史真相的一部分。</li>
</ul>
</li>
<li>难题4的解决方案：举报奖励。<br>例如：分片1上的诚实节点举报分片1上的区块B是恶意的。系统接受了举报，就会惩罚分片 1 里的恶意验证人，没收他们质押的通证，并向举报者提供奖励。所以为什么有的区块链，验证人要收回质押的通证，都需要等几个月。主要的原因就是给举报和证实举报留出足够的时间。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>三个扩容思路，每个都有多种实现，代表性项目如下。</p>
<ul>
<li>代议制扩容的代表是 EOS 和波场。</li>
<li>分层扩容分为状态通道和侧链两个分支，状态通道的方案有 Celer Network、Counterfactual 等，侧链有 Loom、OmiseGo 等。</li>
<li>分片的三个典型方案：Serenity、Polkadot 和 Cosmos 。</li>
</ul>
</li>
</ul>
<h2 id="区块链领域待解决的问题[^_2_]">区块链领域待解决的问题[^ 2 ]</h2><ol>
<li>伸缩性(Scalability):全球范围内花费了多少计算、带宽和存储的资源，来处理单个交易?峰值情况下能处理多少交易? Polkadot</li>
<li>隔离性(Isolatability):多参与方对于应用的差异化需求，能否在同一个框架下接近最优程度地满足? Polkadot</li>
<li>开发性(Developability):工具的工作效果有多好?APIs是否已满足开发者的需求?教程资料是否可用?是否集成权力?</li>
<li>治理性(Governance):网络是否保留了能够随着时间进化和适应的灵活性?制定决策能否高度地包容、合理和透明，来提供去中心化系统的高效领导力。</li>
<li>应用性(Applicability):技术是否真的解决了用户的刚性需求?是否需要其他的中间件来嫁接真实的应用?</li>
</ol>
<h2 id="区块链领域待解决问题的解决方案[^_2_]">区块链领域待解决问题的解决方案[^ 2 ]</h2><ul>
<li>波卡链的工作：针对上述问题1和问题2做了很多工作。扩展性 (extensibilty)和伸缩性(scalability)</li>
<li>波卡认为针对一致性(canonicality)和有效性(validity)绑定的太紧密了。波卡的工作是提出了异构的多链架构，能从本质上把两者拆开。</li>
<li>工作1:解耦底层的共识。<ul>
<li>目标：分离一致性(canonicality)和有效性(validity)，同时保证基本功能（安全性和传输性）。或者说： 从状态转换中解耦底层的共识。</li>
<li>方法：原生的支持内核可扩展(core extensibilty)的可行性方法。Polkadot的方法。</li>
<li>前人方法1：更复杂的可伸缩方案：Chain fibers(by 以太坊的Max Kaye)。创造了：单个中继链(relay-chain)和多个同构链，可以透明地跨链执行的先例。退相干性(Decoherence)通过交易延迟(latency)来实现，这就使需要更长时间，来处理需要协调系统多个部分的交易。</li>
<li>前人方法2:其他人的方法，功能性的解决而非本质层面的解决。归结为：丢弃或减少状态机全局相关性的系统、试图通过同构分片提供全局相关性的单例状态机系统、目标仅是异构性 (heterogeneity)的系统。</li>
<li>前人工作3（没有全局状态的系统：Factom）:公证通(Factom)演示了个没有有效性的一致性系统，能够高效地记载数据。可以被看做是一个可伸缩的方案，严格上来说它只解决了很少的问题。</li>
<li>前人工作4（没有全局状态的系统：Tangle）:Tangle 是个关于共识系统的概念性尝试。不把交易排序再打包到区块中，而是通过串联的共识得出一个全局的一致性状态改变排序，它在很大程度上抛弃了高度结构化的排序 想法，而是推出一个有向无环图</li>
</ul>
</li>
<li>工作2：<ul>
<li>目标：可伸缩性(scalability)问题</li>
<li>思路：对这两个问题分而治之</li>
<li>方法：通过非信任节点的激励机制，弱化他们的内生绑定关系。</li>
<li></li>
</ul>
</li>
</ul>
<p>[^ 2 ]:POLKADOT: VISION FOR A HETEROGENEOUS MULTI-CHAIN FRAMEWORK</p>
]]></content>
      
        <categories>
            
            <category> 区块链 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 跨链 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[主流区块链的技术分析]]></title>
      <url>/2020/02/26/%E4%B8%BB%E6%B5%81%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="主流区块链的技术分析">主流区块链的技术分析</h1><p>创建时间：2020年2月26日</p>
<p>更新时间：2020年2月26日</p>
<p>作者：ShizhiDeng</p>
<p>更新内容：</p>
<ul>
<li><p>2020-02-26 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. Corda针对扩展性问题所做的工作</span><br><span class="line">2. Hyperledger的技术架构</span><br><span class="line">3. 闪电网络的思想和针对扩展性问题做的工作</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Corda">Corda</h2><ol>
<li>针对扩展性问题，Corda的技术思想、解决方法和效果</li>
</ol>
<p><img src="Corda.png" alt="Corda"></p>
<h2 id="Hyperledger">Hyperledger</h2><p><img src="Hyperledger.png" alt="Hyperledger"></p>
<h2 id="Lighting_Network">Lighting Network</h2><p><img src="LightingNetwork.png" alt="LightingNetwork"></p>
]]></content>
      
        <categories>
            
            <category> 区块链 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 区块链 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[区块链和云计算]]></title>
      <url>/2020/02/25/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%92%8C%E4%BA%91%E8%AE%A1%E7%AE%97/</url>
      <content type="html"><![CDATA[<h1 id="区块链和云计算">区块链和云计算</h1><p>创建时间：2020年2月25日</p>
<p>更新时间：2020年2月25日</p>
<p>作者：ShizhiDeng</p>
<p>更新内容：</p>
<ul>
<li><p>2020-02-25 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">阅读文献</span><br><span class="line">1. ProvChain: A Blockchain-based Data Provenance Architecture in Cloud Environment with Enhanced Privacy and Availability</span><br><span class="line">2. Blockchain as a Service for IoT</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="文献调研">文献调研</h2><ol>
<li><p>ProvChain[^ 1 ]</p>
<p>云数据的溯源问题：利用区块链技术，提出了一个去中心化和可信云数据溯源架构，将数据嵌入到区块链交易中，达到(1)溯源元数据采集(2)溯源元数据存储(3)溯源元数据验证。结果证明ProvChain为云存储应用提供了很多安全特性：包括防篡改来源，用户隐私和可靠性。</p>
</li>
<li><p>Blockchain as a Service for IoT [^ 2 ]<br>利用区块链的分布式和去中心化特征，区块链用于管理设备配置、存储传感器用于微支付。部署区块链技术的关键挑战是托管位置。 本文评估了作为托管平台的云和fog服务。</p>
</li>
</ol>
<p>[^ 1 ]: <a href="https://www.researchgate.net/profile/Sachin_Shetty11/publication/317182541_ProvChain_A_Blockchain-Based_Data_Provenance_Architecture_in_Cloud_Environment_with_Enhanced_Privacy_and_Availability/links/5a832cd7aca272d6501c3a6f/ProvChain-A-Blockchain-Based-Data-Provenance-Architecture-in-Cloud-Environment-with-Enhanced-Privacy-and-Availability.pdf" target="_blank" rel="noopener">ProvChain: A Blockchain-based Data Provenance Architecture in Cloud Environment with Enhanced Privacy and Availability</a><br>[^ 2 ]: [Blockchain as a Service for IoT](</p>
]]></content>
      
        <categories>
            
            <category> 区块链 </category>
            
            <category> 云计算 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 区块链 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[区块链的共识算法]]></title>
      <url>/2020/02/25/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1 id="区块链的共识算法">区块链的共识算法</h1><p>创建时间：2020年2月18日</p>
<p>更新时间：2020年2月26日</p>
<p>作者：ShizhiDeng</p>
<p>更新内容：</p>
<ul>
<li><p>2020-02-25 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">重新生成每个算法的总结图，重新整理文章，并发布</span><br></pre></td></tr></table></figure>
</li>
<li><p>2020-02-26</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 投票直接形成共识的BFT类</span><br><span class="line">2. 选举代理人间接参与共识的代理类</span><br><span class="line">3. DAG类共识</span><br></pre></td></tr></table></figure>
<ul>
<li>2020-02-27</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  1. 我的思考更新</span><br><span class="line">  2. 增加共识算法的分类方法2 更新hyperledger部分</span><br><span class="line">  3. Consensus in Hyperledger Fabric(Kafka in Fabric v1)</span><br><span class="line">4. Consensus in Hyperledger Indy (based on RBFT)</span><br><span class="line">  5. Consensus in Hyperledger Iroha(Sumeragi:based on BFT)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="我的思考（持续更）">我的思考（持续更）</h2><ul>
<li>Why consensus?<br>The goal of consensus is to generate an agreement on the order and to validate the correctness of the set of transactions that constitute the block.<ul>
<li>agreement of transaction</li>
<li>validation of transaction</li>
</ul>
</li>
<li>Core function of consensus<ul>
<li>Confirms the correctness of all transactions in a proposed block.</li>
<li>Agrees on order and correctness and hence on results of execution (implies agreement on global state).</li>
<li>Interfaces and depends on smart-contract layer to verify correctness of an ordered set of transactions in a block.</li>
</ul>
</li>
<li><p>Consensus Properties[^ 2 ]</p>
<ul>
<li>Safety: each node is guaranteed the same sequence of inputs and results in the same output on each node. (同一个输入，得到同一个输出)</li>
<li>Liveness: each non-faulty node will eventually receive every submitted transaction, assuming that communication does not fail.</li>
</ul>
</li>
<li><p>节点有相应的概率被选为某个区块的生产者(取得记账权)，在符合一定规则的前提下，由该节点决定区块的内容，再经其 他节点验证。生产合法区块的节点通常可以获得一定的激励。</p>
</li>
<li><p>共识算法：解决一致性问题</p>
</li>
</ul>
<p><img src="区块链的共识算法总结_我的思考.png" alt="区块链的共识算法总结_我的思考"></p>
<h2 id="共识算法的分类方法1">共识算法的分类方法1</h2><p>根据容错，节点参与共识过程的资格，形成共识的依据和共识的内容可以分成四类<a href="[主流区块链共识机制的简介与比较](http://pdf.dfcfw.com/pdf/H3_AP201812271279983589_1.pdf)">^ 1 </a>:</p>
<ul>
<li>Proof of X类</li>
<li>投票直接形成共识的BFT类</li>
<li>选举代理人间接参与共识的代理类</li>
<li>舍弃传统区块概念的DAG类共识</li>
</ul>
<p>整体分类图见下：</p>
<p><img src="区块链的共识算法总结-all.png" alt="区块链的共识算法总结-分成四类"></p>
<p>共识机制的分类标准见下：</p>
<p><img src="区块链的共识算法总结-分类标准.png" alt="区块链的共识算法总结-分类标准"></p>
<h2 id="4类共识机制简析">4类共识机制简析</h2><ol>
<li>Proof of X类共识机制<br>节点获得记账权的概率与该节点拥有某种资源的比例相关，并且这种资源是难以垄断的，同时需要一个能够快速验证某个节点确实拥有这部分资源的算法。<br>该类共识算法有PoW、PoS、PoA/PoSV/Casper、PoST/Proof of Authority：</li>
</ol>
<p><img src="区块链的共识算法总结-PoX类.png" alt="区块链的共识算法总结-PoX类"></p>
<p>   针对PoX类共识机制，分别对上述几种算法总结如下：</p>
<ul>
<li><p>PoW</p>
<p><img src="区块链的共识算法总结-PoW.png" alt="区块链的共识算法总结-PoW"></p>
<ul>
<li><p>PoS<br><img src="区块链的共识算法总结-PoS.png" alt="区块链的共识算法总结-PoS"></p>
</li>
<li><p>PoA<br><img src="区块链的共识算法总结-PoA.png" alt="区块链的共识算法总结-PoA"></p>
</li>
<li><p>PoA<br><img src="区块链的共识算法总结-PoA.png" alt="区块链的共识算法总结-PoA"></p>
</li>
<li><p>Casper<br><img src="区块链的共识算法总结-Casper.png" alt="区块链的共识算法总结-Casper"></p>
</li>
<li><p>Ouroboros<br><img src="区块链的共识算法总结-Ouroboros.png" alt="区块链的共识算法总结-Ouroboros"></p>
</li>
<li><p>PoSV<br><img src="区块链的共识算法总结-PoSV.png" alt="区块链的共识算法总结-PoSV"></p>
</li>
<li><p>其他PoX<br><img src="区块链的共识算法总结-otherPoX.png" alt="区块链的共识算法总结-otherPoX"></p>
</li>
</ul>
</li>
</ul>
<ol>
<li><p>投票直接形成共识的BFT类</p>
<p>该类共识算法有pBFT、dBFT和FBA：<br><img src="区块链的共识算法总结-BFT类共识机制.png" alt="区块链的共识算法总结-BFT类共识机制"></p>
<ul>
<li><p>pBFT</p>
<p><img src="区块链的共识算法总结-pBFT.png" alt="区块链的共识算法总结-pBFT"></p>
<ul>
<li><p>1999年提出，首个高效解决拜占庭容错问题的算法</p>
</li>
<li><p>Hyperledger Fabric曾采用过此共识算法</p>
</li>
<li><p>解决的问题：分布式系统的一致性问题，拜占庭容错问题。</p>
</li>
<li><p>采用的方法：引入“视图”(View)和“主从节点”(Replica)的概念。 Replica 包括主节点(Primary)以及备份节点(Backups)，主节点通常在每一轮共识过程开始时随机选取或者轮流担任。“视图”表示一次主节点分发请求的过程。</p>
<p>当一轮共识开始时，首先检查主节点的有效性。如果备份节点检测到主节点失效，需要选举出新的主节点，称为“视图更换”。共识过程分为包括预准备、准备、确认阶段，又称<strong>“</strong>三阶段协议<strong>”</strong>。</p>
<p><img src="pBFT.png" alt="截屏2020-02-26下午4.41.24"></p>
</li>
<li><p>容错能力：<strong>pBFT</strong> 算法对于一个 <strong>n=3f+1</strong> 个节点组成的区块链网络，可以提供 <strong>f</strong> 的容错能力，容错能力近似为 <strong>1/3</strong>。</p>
</li>
<li><p>pBFT的限制：由于一轮共识过程中节点间的通信次数与𝑛^2^（n为节点数）成正比，考虑到通信延迟的存在，当节点的数量达到一定规模后，<strong>pBFT</strong> 的效率会严重下降。</p>
</li>
</ul>
</li>
<li><p>FBA（Federated Byzantine Agreement 基于联邦拜占庭协议的共识机制）<br><img src="区块链的共识算法总结-FBA.png" alt="区块链的共识算法总结-FBA"></p>
<ul>
<li>思想：通过一种在子网络内部形成信 任(即联邦)，将子网络作为整体视为网络的节点的协议。</li>
<li>基于FBA的共识机制：基于 FBA 的共识机制有RPCA(瑞波共识机制)、恒星共识机制等。</li>
<li>方法：<ul>
<li>RPCA(瑞波共识机制)：节点分验证节点（信任节点列表：UNL Unique Node list）+非验证节点；共识过程分两个阶段：阶段1. 形成交易集的共识（对每一个交易在 UNL 中投票表决，最终得到 80% 投票的交易会被放入交易集中） 阶段2. 形成新区块的共识（广播区块的hash值，比例最高的 Hash值占比超过80%，则达成共识）</li>
<li>恒星共识机制：与 RPCA 类似，恒星共识机制的特点是通过节点可以自由地选择要加入的“联邦”，无需中心化的组织预先选出“服务节点”。</li>
</ul>
</li>
<li>容错能力：RPCA(瑞波共识机制)为1/5。</li>
</ul>
</li>
</ul>
</li>
<li><p>选举代理人间接参与共识的代理类</p>
<ul>
<li><p>BFT类共识机制的限制：参与共识的节点数量有限制，或者参与共识的部分节点必须是可信任的。</p>
</li>
<li><p>目标：一些公共区块链希望尽可能多的节点参与到共识过程中去。</p>
</li>
<li><p>代理共识机制的思想：借鉴现实社会中的选举，网络定期按照节点的得票数选出一定数量的“共识节点”，仅由共识节点完成区块链网络的共识过程。</p>
</li>
<li><p>限制</p>
<ul>
<li>由于见证人的数量有限并且公开，攻击者想要发动DDoS攻击较为容易，见证人需要额外的保护措施，增加了运行共识节点的成本。</li>
<li>具有投票权的节点通常有更大的话语权，甚至可以操纵投票结果。<ul>
<li>如果限制节点的最高投票权重，也可以通过转移通证到不同的节点来规避。 </li>
<li>如果实行“一节点一票”的机制，又会导致“女巫攻击”变得可行。</li>
<li>寻找一个平衡安全性与非中心化的投票算法是较为困难的。</li>
</ul>
</li>
</ul>
</li>
<li><p>该类共识算法有DPoS和DPoS-BFT：<br><img src="区块链的共识算法总结-代理类共识机制.png" alt="区块链的共识算法总结-代理类共识机制"></p>
</li>
<li><p>DPoS</p>
<p><img src="区块链的共识算法总结-DPoS.png" alt="区块链的共识算法总结-DPoS"></p>
<ul>
<li>方法：<ul>
<li>选举见证人：选票前 101 名的节点获得参与网络共识过程的资格，被称为“见证人”。</li>
<li>每个见证人按照一定的顺序(比如随机)轮流获得生产区块的机会，再根据一定的规则对区块链达成共识。</li>
<li>共识方法：根据类似 PoW 的最长链原则选择在高度最高的区块后添加自己的区块。</li>
<li>注意1：各见证人的记账权利是相同的，不因获票数的多少产生区别。</li>
<li>注意2：见证人未能履行义 务或作出不符合整体利益的行为，见证人会被取消记账权。</li>
</ul>
</li>
</ul>
</li>
<li><p>DPoS-BFT</p>
<p><img src="区块链的共识算法总结-DPoS_BFT.png" alt="区块链的共识算法总结-DPoS_BFT"></p>
<ul>
<li>思想：见证人根据获得获得权益支持的多少选出，见证人形成共识的算法可以是 <strong>BFT</strong> 或其他算法。</li>
<li>方法：<ul>
<li>EOS 使用的 DPoS-BFT 共识机制方法：<ul>
<li>股权投票选举出见证人(<strong>EOS</strong> 称为 <strong>BP</strong>，<strong>Block Producer</strong>)的基础上</li>
<li>使用 <strong>BFT</strong> 类算法在 <strong>BP</strong> 之间形成共识。</li>
<li>见证人 21 名，在BFT的三阶段协议中，区块得到15个BP的确认就可最终确认。</li>
</ul>
</li>
<li>NEO 的方法：主要是对见证人形成共识的BFT类算法进行改进<ul>
<li>NEO 网络中有两种通证，管理通证 NEO 以及燃料通证 GAS。</li>
<li>节点根据持有管理通证的份额获得相应数量的选票，选举出一定数量的见证人(共识节点)</li>
<li>由见证人通过改进的pBFT 算法形成共识，生产区块</li>
<li>区块中会有奖励的燃料通证，按持有 NEO 的比例分配给各节点。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>DAG类共识</p>
<p>该类共识算法有如下特点：<br><img src="区块链的共识算法总结-DAG类共识机制.png" alt="区块链的共识算法总结-DAG类共识机制"></p>
<ul>
<li>思想：一般节点维护的交易历史是一个区块组成的哈希链表，特点是单向、线性。修改这种数据结构为IOTA 就是采用有向无环图 DAG (Directed Acyclic Graph)作为记录交易历史的数据结构。</li>
<li>特点和优势：<ul>
<li>Tangle 共识不需要专门负责记账的矿工，而是由新交易给历史交易提供验证，因此不需要交易费用。</li>
<li>不需要将交易打包成区块，交易得到确认的速度取决于新交易 加入Tangle的速度。</li>
</ul>
</li>
<li>缺点<ul>
<li>对交易缺乏过滤机制，因此容易遭到大量垃圾交易的攻击，并且没有有效的机制过滤作恶的节点</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="共识机制对比">共识机制对比</h2><p><img src="区块链的共识算法对比.png" alt="截屏2020-02-26下午6.36.41"></p>
<h2 id="共识算法的分类方法2[^_2_]">共识算法的分类方法2[^ 2 ]</h2><ul>
<li>lottery-based algorithms<ul>
<li>advantages: scale to a large number of nodes since the winner of the lottery proposes a block and transmits it to the rest<br>of the network for validation. </li>
<li>disadvantages: lead to forking when two “winners” propose a block. fork must be resolved, which results in a longer time to finality.</li>
</ul>
</li>
<li>voting-based algorithms<ul>
<li>advantages: low-latency finality</li>
<li>disadvantages: the more nodes that exist on the network, the more time it takes to reach consensus. This results in a trade-off between scalability and speed.</li>
</ul>
</li>
</ul>
<h2 id="Consensus_in_Hyperledger_Fabric(Kafka_in_Fabric_v1)[^_2_][^_3_][^_4_]">Consensus in Hyperledger Fabric(Kafka in Fabric v1)[^ 2 ][^ 3 ][^ 4 ]</h2><ul>
<li>Consensus in Hyperledger Fabric is broken out into 3 phases:<ol>
<li>Endorsement: Endorsement is driven by policy (eg m out of n signatures) upon which participants endorse a transaction.</li>
<li>Ordering: Ordering phase accepts the endorsed transactions and agrees to the order to be committed to the ledger.</li>
<li>Validation: Validation takes a block of ordered transactions and validates the correctness of the results, including checking endorsement policy and double-spending.</li>
</ol>
</li>
<li>ILLUSTRATION OF ONE POSSIBLE TRANSACTION FLOW(COMMON-CASE PATH) IN HYPERLEDGER FABRIC<br><img src="Consensus in Hyperledger Fabric.png" alt="截屏2020-02-27下午4.56.35"></li>
<li>可插拔的共识服务：pluggable consensus service<ul>
<li>the ordering service API allows plugging in BFT-based agreement algorithms</li>
</ul>
</li>
<li>The ordering service API consists of two basic operations: broadcast and deliver.<ul>
<li>broadcast(blob)</li>
<li>deliver(seqno, prevhash, blob)</li>
</ul>
</li>
<li>Multiple ordering plugins are being developed currently, including BFT Smart, Simplified Byzantine Fault Tolerance (SBFT), Honey Badger of BFT, etc.</li>
<li>Fabric v1, Apache Kafka is provided out-of-the-box as a reference implementation.</li>
</ul>
<h2 id="Consensus_in_Hyperledger_Indy_(based_on_RBFT)">Consensus in Hyperledger Indy (based on RBFT)</h2><ul>
<li>Consensus in Hyperledger Indy is based on Redundant Byzantine Fault Tolerance (RBFT)</li>
<li>Like PBFT, RBFT needs at least 3f+1 nodes to handle f faulty nodes. </li>
<li>RBFT overview:<br><img src="Consensus in Hyperledger Indy.png" alt="截屏2020-02-27下午5.23.15"></li>
<li>RBFT protocol steps:<br><img src="Consensus in Hyperledger Indy2.png" alt="截屏2020-02-27下午5.24.33"></li>
</ul>
<h2 id="Consensus_in_Hyperledger_Iroha(Sumeragi:based_on_BFT)">Consensus in Hyperledger Iroha(Sumeragi:based on BFT)</h2><ul>
<li>Insipered by B-Chain Algorithm described by Duan, Meling, Peisert, &amp; Zhang (2014).</li>
<li>Concept of a global order over validating peers and sets A and B of peers, where A consists of the first 2f+1 peers and B consists of the remainder.<br><img src="Consensus in Hyperledger Iroha.png" alt="截屏2020-02-27下午5.30.17"></li>
<li>The order of processing nodes is determined based on the server reputation system called hijiri. </li>
<li>The case of a failure in the proxy tail is shown in Figure below<br><img src="Consensus in Hyperledger Iroha2.png" alt="截屏2020-02-27下午5.35.24"></li>
<li>Consensus in Sumeragi is performed on individual transactions and on the global state resulting from the application of the transaction. When a validating peer receives a transaction over the network, it performs the following steps in order:<ol>
<li>Validate the signature (or signatures, in the case of multi-signature transactions) of the transaction.</li>
<li>Validate the contents of the transaction, where applicable. For example, transfer transactions must leave the payer’s account with a non-negative balance.</li>
<li>Temporarily apply the transaction to the ledger. This involves updating the Merkle root of the global state.</li>
<li>Sign the updated Merkle root and the hash of the transaction contents.</li>
<li>Broadcast the tuple, which is a finite ordered list of transactions.</li>
<li>When syncing nodes with each other, valid parts of the Merkle tree are shared until the roots match.</li>
</ol>
</li>
</ul>
<h2 id="Consensus_in_Hyperledger_Sawtooth(based_on_PoET)">Consensus in Hyperledger Sawtooth(based on PoET)</h2><ul>
<li>PoET: Proof of Elapsed Time </li>
<li>Hyperledger Sawtooth facilitates pluggable consensus for both lottery and voting algorithms. </li>
<li>Default algorithm: lottery-based, Nakamoto consensus algorithm called PoET. </li>
<li>PoET uses a lottery for leader election based on a guaranteed wait time provided through a Trusted Execution Environment (TEE) (Sandell, Bowman, &amp; Shah, 2016). The current implementation of Hyperledger Sawtooth builds on a TEE provided by Intel’s Software Guard Extensions (SGX). </li>
<li>A good lottery function satisfies:<ul>
<li>Fairness - The function should distribute leader election across the broadest possible population of participants.</li>
<li>Investment - The cost of controlling the leader election process should be proportional to the value gained from it.</li>
<li>Verification - It should be relatively simple for all participants to verify that the leader was legitimately selected.</li>
</ul>
</li>
</ul>
<h2 id="Paxos">Paxos</h2><p>[^ 2 ]: Hyperledger Architecture, Volume 1 Introduction to Hyperledger Business Blockchain Design Philosophy and Consensus</p>
<p>[^ 3 ]: <a href="https://hyperledger-fabric.readthedocs.io/en/release-1.4/txflow.html" target="_blank" rel="noopener">Fabric Transaction Flow</a></p>
<p>[^ 4 ]: <a href="https://www.skcript.com/svr/consensus-hyperledger-fabric/" target="_blank" rel="noopener">The Ultimate Guide to Consensus in Hyperledger Fabric</a></p>
]]></content>
      
        <categories>
            
            <category> 区块链 </category>
            
            <category> 共识算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 共识算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Technical Analysis of Hyperledger]]></title>
      <url>/2020/02/14/Technical%20Analysis%20of%20Hyperledger/</url>
      <content type="html"><![CDATA[<h1 id="Technical_Analysis_of_Hyperledger">Technical Analysis of Hyperledger</h1><p>CreateDate: 2020-02-14<br>UpdateDate: 2020-02-27<br>Author: ShizhiDeng<br>Update content:</p>
<ul>
<li><p>2020-02-27</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">完成Hyperledger技术分析多个主题：比如基本信息、技术架构、技术分析之解决的</span><br><span class="line">问题1：在分布式数据库中如何分享数据。</span><br><span class="line">问题2:如何实现Hyperledger的模块化特性。</span><br><span class="line">问题3：Hyperledger如何实现交易的一致性和有效性，也就是共识算法的技术细节</span><br><span class="line"></span><br><span class="line">参考文献</span><br><span class="line">1. An Introduction to Hyperledger</span><br><span class="line">2. Hyperledger Architecture, Volume 1 Introduction to Hyperledger Business Blockchain Design Philosophy and Consensus</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Some_basic_information_about_Hyperledger[^_1_][^_2_]">Some basic information about Hyperledger[^ 1 ][^ 2 ]</h2><ul>
<li>What is Hyperledger<br>  Hyperledger is an open source collaborative effort created to advance cross-industry blockchain technologies. It is a global collaboration, hosted by The Linux Foundation, including leaders in finance, banking, Internet of Things, supply chains, manufacturing, and Technology.</li>
<li>Some numbers about Hyperledger<br>  Hyperledger began in 2015.<br>  As of publication date, Hyperledger has more than 230 organizations as members—from Airbus to VMware—as well as 10 projects with 3.6 million lines of code, 10 active working groups, and close to 28,000 participants who have come to 110+ meetups around the world. Through 2017, the project was mentioned in the press an average of 1,500 times a month.</li>
<li>Current Hyperledger projects: Frameworks and Tools<br>The Hyperledger greenhouse structure is shown in the figure 1 as following:<br><img src="THE HYPERLEDGER GREENHOUSE STRUCTURE.png" alt="THE HYPERLEDGER GREENHOUSE STRUCTURE" style="zoom:40%;"></li>
<li><p>Hyperledger Design Philosophy<br>  We recognize that different enterprise scenarios have different requirements for confirmation times, decentralization, trust, and other issues, and that each issue represents a potential “optimization point” for the technology.<br>  All Hyperledger projects follow the same design philosophy. All our projects must be:</p>
<ul>
<li>Modular</li>
<li>Highly secure</li>
<li>Interoperable</li>
<li>Cryptocurrency-agnostic</li>
<li><p>Complete with APIs</p>
<p><img src="THE HYPERLEDGER DESIGN PHILOSOPHY.png" alt="THE HYPERLEDGER DESIGN PHILOSOPHY" style="zoom: 50%;"></p>
</li>
</ul>
</li>
<li>Hyperledger Goals[^ 3 ]<ul>
<li>Create enterprise grade, open source, distributed ledger frameworks &amp; code bases to support business transactions.</li>
<li>Provide neutral, open, &amp; community-driven infrastructures supported by technical and business governance.</li>
<li>Build technical communities to develop blockchain and shared ledger POCs, use cases, field trials and deployments.</li>
<li>Educate the public about the market opportunity for blockchain technology.</li>
<li>Promote our community of communities taking a toolkit approach with many platforms and frameworks.</li>
</ul>
</li>
<li>Why open source for blockchain?<ul>
<li>Competitive features and capabilities</li>
<li>No vendor lock-in, so customers can easily switch</li>
<li>High-quality solutions</li>
<li>The ability to customize and fix bugs, through access to source code</li>
<li>Lower total cost of ownership</li>
<li>some popular open source projects:Linux,Apache web server,MySQL,Fiox</li>
</ul>
</li>
<li>Application scenario of Hyperledger<ul>
<li>Banking—applying for a loan</li>
<li>Financial services—post-trade processing</li>
<li>Healthcare—credentialing physicians</li>
<li>IT—managing portable identities</li>
<li>Supply chain management—tracking fish from ocean to table</li>
</ul>
</li>
</ul>
<h2 id="Current_Hyperledger_projects">Current Hyperledger projects</h2><ul>
<li><p>Current Hyperledger projects: Frameworks<br>  Hyperledger incubates and promotes a range of business blockchain technologies, including:</p>
<ul>
<li>Distributed ledger frameworks</li>
<li>Smart contract engines</li>
<li>Client libraries</li>
<li>Graphical interfaces</li>
<li>Utility libraries</li>
<li><p>Sample applications</p>
<p>Summary of Hyperledger Frameworks:</p>
<p>| Hyperledger Frameworks |                         Description                          |<br>| :——————————: | :—————————————————————————————: |<br>|   HYPERLEDGER BURROW   | A modular blockchain client with a permissioned smart contract interpreter developed in part to the specifications of the Ethereum Virtual Machine (EVM). |<br>|   HYPERLEDGER FABRIC   | A platform for building distributed ledger solutions with a modular architecture that delivers a high degree of confidentiality, flexibility, resiliency, and scalability. This enables solutions developed with Fabric to be adapted for any industry. |<br>|    HYPERLEDGER INDY    | A distributed ledger that provides tools, libraries, and reusable components purpose-built for decentralized identity. |<br>|   HYPERLEDGER IROHA    | A blockchain framework designed to be simple and easy to incorporate into enterprise infrastructure projects. |<br>|  HYPERLEDGER SAWTOOTH  | A modular platform for building, deploying, and running distributed ledgers. Sawtooth features a new type of consensus, proof of elapsed time (PoET) which consumes far fewer resources than proof of work (PoW). |</p>
</li>
</ul>
</li>
<li><p>Current Hyperledger projects: Tools<br>Hyperledger incubates and promotes a range of business blockchain technologies, including tools and utility libraries.</p>
<p>The Hyperledger strategy encourages the re-use of common building blocks, enables rapid innovation of components, and promotes interoperability between projects.</p>
<p>Summary of Hyperledger Tools:</p>
<p>| Hyperledger Frameworks |                         Description                          |<br>| :——————————: | :—————————————————————————————: |<br>|  HYPERLEDGER CALIPER   | A blockchain benchmark tool that measures the performance of any blockchain by using a set of predefined use cases. |<br>|   HYPERLEDGER CELLO    | A set of tools to bring the on-demand deployment model to the blockchain ecosystem with automated ways to provision and manage blockchain operations that reduce effort. |<br>|  HYPERLEDGER COMPOSER  | An open development toolset and framework to make developing blockchain applications easier. |<br>|  HYPERLEDGER EXPLORER  | A dashboard for viewing information on the network, including blocks, node logs, statistics, smart contracts, and transactions. |<br>|   HYPERLEDGER QUILT    | A set of tools that offer interoperability by implementing ILP, which is primarily a payments protocol designed to transfer value across distributed and non-distributed ledgers. |</p>
</li>
</ul>
<h2 id="Technology_of_Hyperleger">Technology of Hyperleger</h2><p>All Hyperledger projects follow a design philosophy that includes a modular extensible approach, interoperability, an emphasis on highly secure solutions, a token-agnostic approach with no native cryptocurrency, and the development of a rich and easy-to- use Application Programming Interface (API). The Hyperledger Architecture WG has distinguished the following business blockchain components:</p>
<ul>
<li>Consensus Layer - Responsible for generating an agreement on the order and confirming the correctness of the set of transactions that constitute a block.</li>
<li>Smart Contract Layer - Responsible for processing transaction requests and determining if transactions are valid by executing business logic.<ul>
<li>Hyperledger Burrow - Smart contract application engine</li>
<li>Hyperledger Fabric - Chaincode</li>
<li>Hyperledger Indy - None</li>
<li>Hyperledger Iroha2 - Chaincode</li>
<li>Hyperledger Sawtooth - Transaction familiesc</li>
</ul>
</li>
<li>Communication Layer - Responsible for peer-to-peer message transport between the nodes that participate in a shared ledger instance.</li>
<li>Data Store Abstraction - Allows different data-stores to be used by other modules.</li>
<li>Crypto Abstraction - Allows different crypto algorithms or modules to be swapped out without affecting other modules.</li>
<li>Identity Services - Enables the establishment of a root of trust during setup of a blockchain instance, the enrollment and registration of identities or system entities during network operation, and the management of changes like drops, adds, and revocations. Also, provides authentication and authorization.</li>
<li>Policy Services - Responsible for policy management of various policies specified in the system, such as the endorsement policy, consensus policy, or group management policy. It interfaces and depends on other modules to enforce the various policies.</li>
<li>APIs - Enables clients and applications to interface to blockchains.</li>
<li><p>Interoperation - Supports the interoperation between different blockchain instances.</p>
<p><img src="Hyperledger.png" alt="Hyperledger"></p>
</li>
</ul>
<h2 id="Possible_improvement_in_Hyperledger">Possible improvement in Hyperledger</h2><ul>
<li>The future of blockchain(Hyperledger Participants’ opinion)<ul>
<li>modular</li>
<li>open-source </li>
<li>easy to use. </li>
</ul>
</li>
</ul>
<h2 id="Hyperledger_design_philosophy_for_permissioned_blockchain_networks[^_5_]">Hyperledger design philosophy for permissioned blockchain networks[^ 5 ]</h2><h2 id="Hyperledger_consensus_technical_analysis[^_5_]">Hyperledger consensus technical analysis[^ 5 ]</h2><ul>
<li></li>
</ul>
<h2 id="approach_optimizes_the_development_of_flexible,_interoperable_enterprise_blockchain_technologies">approach optimizes the development of flexible, interoperable enterprise blockchain technologies</h2><h2 id="a_generalized_reference_architecture_for_consensus">a generalized reference architecture for consensus</h2><h2 id="Technical_Analysis">Technical Analysis</h2><p>The road of technical analysis accord to following route. Especially, the problems that I list below are common and basic:</p>
<ol>
<li>What is the problem?</li>
<li>Technical solution of the problem.</li>
<li>Evaluation of the solution.</li>
<li>My solution and thinking into the problem. </li>
</ol>
<h3 id="Problem1:share_data_in_a_distributed_database">Problem1:share data in a distributed database</h3><ul>
<li><p>Problem description: Many people will want to share data in a distributed database, but no single owner will be trusted by every user.</p>
</li>
<li><p>Solution: distributed ledger technology (DLT). </p>
</li>
<li><p>Difficulty: Security,privacy and performance are incompatible.So no one blockchain will work best for all applications.It suggests that we’ll need a variety of different blockchains that can all communicate and interact seamlessly. </p>
</li>
<li><p>The concerns according to above analysis: modular and interoperable.</p>
</li>
</ul>
<h3 id="Problem2:_How_to_achieve_the_modular_feature_of_a_blockchain">Problem2: How to achieve the modular feature of a blockchain</h3><ol>
<li>Solution1: work by Hyperledger <ul>
<li>分层：包括共识层、智能合约层、通信层、数据存储抽象、加密抽象、认证服务、策略服务、API、交互操作等</li>
<li>针对私有链business blockchain，hyperledger共识层也分成了两部分：1. Ordering of transactions 2. Validating transactions</li>
</ul>
</li>
</ol>
<h3 id="Problem3:_How_to_achieve_the_interoperable_feature_of_a_blockchain">Problem3: How to achieve the interoperable feature of a blockchain</h3><h3 id="Problem4:_How_to_achieve_the_agreement_of_transaction_and_validation_of_transaction_in_Hyperledger?">Problem4: How to achieve the agreement of transaction and validation of transaction in Hyperledger?</h3><ul>
<li>Solution: Consensus in Hyperledger frameworks.</li>
<li>Consensus(Hyperledger business blockchain frameworks) is divided to two seperate activities: <ol>
<li>Ordering of transactions </li>
<li>Validating transactions</li>
</ol>
</li>
<li>The consensus process flow:<ol>
<li>receiving the transactions from the client application. </li>
<li>ordering service: order transactions<ul>
<li>can be implemented in different ways: a centralized service(development and testing) and distributed protocols(different network and node fault models)</li>
<li>confidentiality of the transactions: the transaction content can be hashed or encrypted.</li>
<li>Transactions are submitted via an interface to the ordering service.</li>
</ul>
</li>
<li>validate transactions: consensus depends on the smart contract layer(because it contains the business logic behind what makes a transaction valid.)<ul>
<li>validation errors: <ol>
<li>syntax errors: invalid inputs, unverifiable signature, and repeated transaction (due to error or replay attacks) </li>
<li>logic errors:  policy driven whether to continue processing or not. (Example: result in double-spend or versioning control failure. )</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="Problem2:interoperability_of_different_blockchains">Problem2:interoperability of different blockchains</h3><p>Problem description: We’ll find merit in many different blockchains.In many scenarios,different blockchains need communication with each other.</p>
<p>Solution: </p>
<h2 id="References">References</h2><p>[^ 2 ]: <a href="https://www.hyperledger.org/wp-content/uploads/2018/08/HL_Whitepaper_IntroductiontoHyperledger.pdf" target="_blank" rel="noopener">An Introduction to Hyperledger</a>Hyperledger介绍，基本信息，目标，当前项目，应用场景等。</p>
<p>[^ 3 ]: <a href="https://www.hyperledger.org/wp-content/uploads/2018/02/Hyperledger-Overview_February-2018-2.pdf" target="_blank" rel="noopener">Hyperledger Overview</a>介绍内容的总结PPT</p>
<p>[^ 4 ]: <a href="https://developer.ibm.com/cn/tv/2017/blockchain-and-hyperledger/" target="_blank" rel="noopener">开源技术微讲堂：区块链和 HyperLedger 系列</a></p>
<p>[^ 5 ]: Hyperledger Architecture, Volume 1 Introduction to Hyperledger Business Blockchain Design Philosophy and Consensus</p>
]]></content>
      
        <categories>
            
            <category> 区块链 </category>
            
            <category> Hyperledger </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> Hyperledger </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[The Story of Block Chain]]></title>
      <url>/2020/02/07/Story%20of%20Block%20Chain_Release/</url>
      <content type="html"><![CDATA[<h2 id="BitCoin_Basis">BitCoin Basis</h2><pre><code>* <span class="type">Block</span> <span class="type">Chain</span> <span class="type">Version</span> <span class="number">1</span>.<span class="number">0</span>
* <span class="type">What</span> <span class="keyword">is</span> <span class="type">Bitcoin</span>?
    * <span class="type">Bitcoin</span> <span class="keyword">is</span> a cryptocurrency. <span class="type">It</span> <span class="keyword">is</span> a decentralized digital currency <span class="keyword">without</span> a central bank <span class="keyword">or</span> single administrator that can be sent <span class="keyword">from</span> user to user on the peer-to-peer bitcoin network <span class="keyword">without</span> the need <span class="keyword">for</span> intermediaries.(<span class="keyword">from</span> https://en.wikipedia.org/wiki/<span class="type">Bitcoin</span>)
    * cryptocurrency
    * decentralized
    * peer-to-peer bitcoin network
* <span class="type">Brief</span> history
    * <span class="number">2008</span> - <span class="type">The</span> <span class="type">Bitcoin</span> <span class="type">White</span> <span class="type">Paper</span> <span class="keyword">is</span> <span class="type">Released</span>
    * <span class="type">Jan</span> <span class="number">2009</span> - <span class="type">First</span> <span class="type">Bitcoin</span> <span class="type">Block</span> <span class="keyword">is</span> <span class="type">Mined</span>
    * <span class="type">Jan</span> <span class="number">2009</span> - <span class="type">First</span> <span class="type">Bitcoin</span> <span class="type">Transaction</span>
    * <span class="type">Oct</span> <span class="number">2009</span> - <span class="type">First</span> listed <span class="type">Dollar</span> to <span class="type">Bitcoin</span> <span class="type">Exchage</span> <span class="type">Rate</span>
    * <span class="type">May</span> <span class="number">2010</span> - <span class="type">First</span> <span class="type">Real</span> <span class="type">World</span> <span class="type">Bitcoin</span> <span class="type">Purchase</span>
    * <span class="type">Feb</span> <span class="number">2011</span> - <span class="type">Silk</span> <span class="type">Road</span> <span class="type">Marketplace</span> <span class="type">Opens</span>
    * <span class="type">Nov</span> <span class="number">2013</span> - <span class="type">Price</span> hits $<span class="number">1242</span> <span class="keyword">for</span> a single <span class="type">Bitcoin</span>
    * <span class="type">Feb</span> <span class="number">2014</span> - <span class="type">Mt</span>.<span class="type">Gox</span> gets hacked, $<span class="number">450</span> million missing 
    * <span class="type">Dec</span> <span class="number">2014</span> - <span class="type">Microsoft</span> adds <span class="type">Bitcoin</span> <span class="type">Payments</span> to <span class="type">Xbox</span> live
* <span class="type">Cryptographic</span> hash function (<span class="type">Backbone</span> <span class="keyword">of</span> the <span class="type">Bitcoin</span> <span class="type">Network</span>)
    * <span class="type">MD5</span>(<span class="type">MD4</span>);<span class="type">SHA</span>-<span class="number">256</span>(<span class="type">SHA</span>-<span class="number">1</span>);<span class="type">RIPEMD</span>,<span class="type">BLAKE</span>,<span class="type">Skein</span>
    * first application: <span class="type">Digital</span> <span class="type">Signatures</span>
    * puzzle friendly: difficult to solve,easy to verify    
    * <span class="type">Cryptographic</span> <span class="keyword">is</span> very important!
        * determined: same input same output
        * computationally efficient
        * <span class="type">Collision</span> resistance: different inputs,different output. hard to find two inputs that actually map to same output.
        * hiding information about input
        * <span class="type">Digest</span> should look random
    * ref1: https://youtu.be/<span class="number">0</span>WiTaBI82Mc
* <span class="type">Digital</span> <span class="type">Signature</span>
    * a digital signature scheme <span class="keyword">is</span> a triple <span class="keyword">of</span> probabilistic polynomial time algorithms, (G, S, V), satisfying:
        G (key-generator) generates a public key (pk), <span class="keyword">and</span> a corresponding private key (sk), on input <span class="number">1</span>n, where n <span class="keyword">is</span> the security parameter.
        S (signing) returns a tag, t, on the inputs: the private key (sk), <span class="keyword">and</span> a <span class="type">string</span> (x).
        V (verifying) outputs accepted <span class="keyword">or</span> rejected on the inputs: the public key (pk), a <span class="type">string</span> (x), <span class="keyword">and</span> a tag (t).
    * <span class="keyword">ref</span>: https://en.wikipedia.org/wiki/<span class="type">Digital_signature</span>
* <span class="type">Merkle</span> <span class="type">Tree</span>
    * <span class="type">In</span> cryptography <span class="keyword">and</span> computer science, a hash tree <span class="keyword">or</span> <span class="type">Merkle</span> tree <span class="keyword">is</span> a tree <span class="keyword">in</span> which every leaf node <span class="keyword">is</span> labelled <span class="keyword">with</span> the cryptographic hash <span class="keyword">of</span> a data <span class="keyword">block</span>, <span class="keyword">and</span> every non-leaf node <span class="keyword">is</span> labelled <span class="keyword">with</span> the hash <span class="keyword">of</span> the labels <span class="keyword">of</span> its child nodes. 
    * <span class="type">Block</span> chain <span class="keyword">is</span> a linked list <span class="keyword">using</span> hash pointers.
    * <span class="type">Proof</span> <span class="keyword">of</span> membership (<span class="type">Proof</span> <span class="keyword">of</span> inclusion):
        * <span class="type">Merkle</span> proof: find the position <span class="keyword">of</span> <span class="type">TX</span>,<span class="keyword">and</span> calculate the root hash. <span class="type">Make</span> the validation <span class="keyword">of</span> caculated root hash. <span class="type">Complexity</span>: O(log(n))
    * <span class="type">Proof</span> <span class="keyword">of</span> non-membership:
        * <span class="type">Send</span> all the struction <span class="keyword">of</span> trees to light node, check it. complexity: O(n)
        * <span class="type">Sorted</span> <span class="type">Merkle</span> <span class="type">Tree</span>: <span class="keyword">is</span> <span class="keyword">not</span> used <span class="keyword">in</span> <span class="type">Bitcoin</span>,because <span class="type">Bitcoin</span> donot need proof <span class="keyword">of</span> non-membership. <span class="type">Complexity</span>: O(log(n))
    * <span class="keyword">ref</span>: https://en.wikipedia.org/wiki/<span class="type">Merkle_tree</span>
* <span class="type">UTXO</span>
    * <span class="type">UTXO</span>: <span class="type">Unspent</span> <span class="type">Transaction</span> <span class="type">Output</span>
    * goal: check double spending 
    * a <span class="type">TX</span> has many inputs <span class="keyword">and</span> many outputs,but which statisfies: 
        * all the <span class="type">TX</span> come <span class="keyword">from</span> coinbase
        * all the <span class="type">TX</span> inputs come <span class="keyword">from</span> <span class="type">UTXO</span> outputs <span class="keyword">of</span> one <span class="keyword">or</span> many <span class="type">TXs</span> <span class="keyword">except</span> <span class="type">TX</span> <span class="keyword">of</span> coinbase
        * total inputs = total outputs
* <span class="type">Script</span> model <span class="keyword">in</span> <span class="type">Bitcoin</span> 
    * only stack: <span class="type">LIFO</span>, <span class="type">Last</span> <span class="type">In</span> <span class="type">First</span> <span class="type">Out</span>. https://zh.wikipedia.org/wiki/%<span class="type">E5</span>%<span class="type">A0</span>%<span class="number">86</span>%<span class="type">E6</span>%<span class="type">A0</span>%<span class="number">88</span>
    * <span class="type">P2PKH</span>(<span class="type">Pay</span> to <span class="type">Public</span> <span class="type">Key</span> <span class="type">Hash</span>) <span class="keyword">is</span> most common. <span class="type">P2PKH</span>: &lt;sig&gt; &lt;<span class="type">PubK</span>&gt; <span class="type">DUP</span> <span class="type">HASH160</span> &lt;<span class="type">PubKHash</span>&gt; <span class="type">EQUALVERIFY</span> <span class="type">CHECKSIG</span> <span class="keyword">ref</span>:
    * <span class="type">P2SH</span>(<span class="type">Pay</span> to script hash): used <span class="keyword">in</span> <span class="type">MultiSig</span>. <span class="type">P2SH</span>: <span class="type">HASH160</span> <span class="type">PUSHDATA</span>(goal script hash) <span class="type">EQUAL</span> <span class="keyword">ref</span>:https://en.bitcoin.it/wiki/<span class="type">Pay_to_script_hash</span>
    * <span class="type">Proof</span> <span class="keyword">of</span> <span class="type">Burn</span>: <span class="type">First</span> scene：<span class="type">Burn</span> <span class="type">Bitcoin</span> <span class="keyword">and</span> get some <span class="type">AltCoins</span>(<span class="type">Alternative</span> <span class="type">Coin</span>). <span class="type">Second</span> scene: digital commitment(hash the commitment content)
    * <span class="keyword">ref</span> https://en.bitcoin.it/wiki/<span class="type">Script</span>
    * <span class="type">CHECKMULTISIG</span>:has a bug,so push a <span class="number">0</span> to stack first.
* <span class="type">Security</span> <span class="keyword">in</span> <span class="type">Bitcoin</span>
    * <span class="type">Cryptography</span>: source <span class="keyword">is</span> random
    * <span class="type">Consensus</span> <span class="keyword">in</span> <span class="type">BitCoin</span>: legal identity <span class="keyword">ref</span>: https://zh.wikipedia.org/wiki/%<span class="type">E5</span>%<span class="number">85</span>%<span class="type">B1</span>%<span class="type">E8</span>%<span class="type">AD</span>%<span class="number">98</span>%<span class="type">E6</span>%<span class="type">A9</span>%<span class="number">9</span>F%<span class="type">E5</span>%<span class="number">88</span>%<span class="type">B6</span>
    * <span class="type">Possible</span> <span class="type">Attack</span>
        * double spending attack: longest valid chain
        * sybil attack
        * forking attack: six confirmation
        * selfish mining
* <span class="type">Principle</span> <span class="keyword">in</span> <span class="type">Designing</span> <span class="type">Bitcoin</span>
    * simple,robust but <span class="keyword">not</span> efficient
* ref1: https://youtu.be/<span class="number">5</span>fSOd431l6A
* ref2: https://bitcoin.org/bitcoin.pdf
</code></pre><h2 id="Ethereum">Ethereum</h2><pre><code>* <span class="type">Block</span> <span class="type">Chain</span> <span class="type">Version</span> <span class="number">2</span>.<span class="number">0</span>
* <span class="type">Smart</span> <span class="type">Contract</span>
    * <span class="type">What</span> <span class="keyword">is</span> <span class="type">Smart</span> <span class="type">Contract</span>? 
        * <span class="type">Smart</span> <span class="type">Contract</span> <span class="keyword">is</span> a piece <span class="keyword">of</span> code running <span class="keyword">in</span> <span class="type">Block</span> <span class="type">Chain</span>. <span class="type">The</span> code defines the content <span class="keyword">of</span> contract. (by <span class="type">ZhenXiao</span>)
        * A smart contract <span class="keyword">is</span> a computer protocol intended to digitally facilitate, verify, <span class="keyword">or</span> enforce the negotiation <span class="keyword">or</span> performance <span class="keyword">of</span> a contract. <span class="type">Smart</span> contracts allow the performance <span class="keyword">of</span> credible transactions <span class="keyword">without</span> third parties. <span class="type">These</span> transactions are trackable <span class="keyword">and</span> irreversible.
        <span class="keyword">ref</span>:https://en.wikipedia.org/wiki/<span class="type">Smart_contract</span>
    * smart contract account: nonce(count number <span class="keyword">of</span> transaction);balance;storageRoot(datastructure:<span class="type">MPT</span>);codeHash
* <span class="type">EVM</span>(<span class="type">Ethereum</span> <span class="type">Virtual</span> <span class="type">Machine</span>)
    * <span class="type">Goal</span>: <span class="type">Enforce</span> <span class="type">Consistency</span>. <span class="type">Just</span> like <span class="type">JVM</span>.
    * <span class="type">What</span> <span class="keyword">is</span> <span class="type">EVM</span>?
        <span class="type">The</span> <span class="type">Ethereum</span> <span class="type">Virtual</span> <span class="type">Machine</span> (<span class="type">EVM</span>) <span class="keyword">is</span> a powerful, sandboxed virtual stack embedded within each full <span class="type">Ethereum</span> node, responsible <span class="keyword">for</span> executing contract bytecode. <span class="type">Contracts</span> are typically written <span class="keyword">in</span> higher level languages, like <span class="type">Solidity</span>, then compiled to <span class="type">EVM</span> bytecode.
    * <span class="type">Process</span>
        * <span class="type">Smart</span> contracts are often written <span class="keyword">in</span> a programming language(<span class="type">Solidity</span>,<span class="type">Vyper</span>,<span class="type">Bamboo</span>;<span class="type">Serpent</span>,<span class="type">Mutan</span>).
        * <span class="type">Smart</span> contract languages like <span class="type">Solidity</span> cannot be executed by the <span class="type">EVM</span> directly. <span class="type">Instead</span>, they are compiled to low-level machine instructions (called opcodes).
    * <span class="type">Opcodes</span>
        * <span class="type">Stack</span>-manipulating opcodes (<span class="type">POP</span>, <span class="type">PUSH</span>, <span class="type">DUP</span>, <span class="type">SWAP</span>)
        * <span class="type">Arithmetic</span>/comparison/bitwise opcodes (<span class="type">ADD</span>, <span class="type">SUB</span>, <span class="type">GT</span>, <span class="type">LT</span>, <span class="type">AND</span>, <span class="type">OR</span>)
        * <span class="type">Environmental</span> opcodes (<span class="type">CALLER</span>, <span class="type">CALLVALUE</span>, <span class="type">NUMBER</span>)
        * <span class="type">Memory</span>-manipulating opcodes (<span class="type">MLOAD</span>, <span class="type">MSTORE</span>, <span class="type">MSTORE8</span>, <span class="type">MSIZE</span>)
        * <span class="type">Storage</span>-manipulating opcodes (<span class="type">SLOAD</span>, <span class="type">SSTORE</span>)
        * <span class="type">Program</span> counter related opcodes (<span class="type">JUMP</span>, <span class="type">JUMPI</span>, <span class="type">PC</span>, <span class="type">JUMPDEST</span>)
        * <span class="type">Halting</span> opcodes (<span class="type">STOP</span>, <span class="type">RETURN</span>, <span class="type">REVERT</span>, <span class="type">INVALID</span>, <span class="type">SELFDESTRUCT</span>)
    * <span class="type">Bytecode</span>
        * <span class="type">In</span> order to efficiently store opcodes, they are encoded to bytecode. <span class="type">Every</span> opcode <span class="keyword">is</span> allocated a byte (<span class="keyword">for</span> example; <span class="type">STOP</span> <span class="keyword">is</span> <span class="number">0x00</span>). 
    * <span class="keyword">ref</span> https://medium.com/mycrypto/the-ethereum-virtual-machine-how-does-it-work-<span class="number">9</span>abac2b7c9e
* <span class="type">State</span> <span class="type">Transition</span> <span class="keyword">in</span> <span class="type">Ethereum</span>
    <span class="type">The</span> <span class="type">Ethereum</span> state transition function, <span class="type">APPLY</span>(S,<span class="type">TX</span>) -&gt; S' can be defined <span class="keyword">as</span> follows:
    <span class="number">1</span>. <span class="type">Check</span> <span class="keyword">if</span> the transaction <span class="keyword">is</span> well-formed (ie. has the right number <span class="keyword">of</span> values), the signature <span class="keyword">is</span> valid,
    <span class="keyword">and</span> the nonce matches the nonce <span class="keyword">in</span> the sender's account. <span class="type">If</span> <span class="keyword">not</span>, <span class="keyword">return</span> an error.
    <span class="number">2</span>. <span class="type">Calculate</span> the transaction fee <span class="keyword">as</span> <span class="type">STARTGAS</span> * <span class="type">GASPRICE</span>, <span class="keyword">and</span> determine the sending address <span class="keyword">from</span>
    the signature. <span class="type">Subtract</span> the fee <span class="keyword">from</span> the sender's account balance <span class="keyword">and</span> increment the sender's
    nonce. <span class="type">If</span> there <span class="keyword">is</span> <span class="keyword">not</span> enough balance to spend, <span class="keyword">return</span> an error.
    <span class="number">3</span>. <span class="type">Initialize</span> <span class="type">GAS</span> = <span class="type">STARTGAS</span>, <span class="keyword">and</span> take off a certain quantity <span class="keyword">of</span> gas per byte to pay <span class="keyword">for</span> the bytes <span class="keyword">in</span>
    the transaction.
    <span class="number">4</span>. <span class="type">Transfer</span> the transaction value <span class="keyword">from</span> the sender's account to the receiving account. <span class="type">If</span> the receiving
    account does <span class="keyword">not</span> yet exist, create it. <span class="type">If</span> the receiving account <span class="keyword">is</span> a contract, run the contract's code
    either to completion <span class="keyword">or</span> until the execution runs <span class="keyword">out</span> <span class="keyword">of</span> gas.
    <span class="number">5</span>. <span class="type">If</span> the value transfer failed because the sender did <span class="keyword">not</span> have enough money, <span class="keyword">or</span> the code execution
    ran <span class="keyword">out</span> <span class="keyword">of</span> gas, revert all state changes <span class="keyword">except</span> the payment <span class="keyword">of</span> the fees, <span class="keyword">and</span> add the fees to the
    miner's account.
    <span class="number">6</span>. <span class="type">Otherwise</span>, refund the fees <span class="keyword">for</span> all remaining gas to the sender, <span class="keyword">and</span> send the fees paid <span class="keyword">for</span> gas
    consumed to the miner.
    * <span class="keyword">ref</span>: https://blockchainlab.com/pdf/<span class="type">Ethereum_white_paper</span>-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf
* <span class="type">State</span> <span class="type">Management</span>
    * <span class="type">Ethereum</span> <span class="keyword">is</span> a state machine based on the transaction.
    * <span class="type">The</span> state <span class="keyword">in</span> <span class="type">Ethereum</span> actually <span class="keyword">is</span> data store locally <span class="keyword">in</span> form <span class="keyword">of</span> state tries.
    * <span class="type">Account</span>-based ledger (<span class="type">Bitcoin</span>: <span class="type">Transaction</span>-based ledger,<span class="type">UTXO</span>) 
    * externally owned account: nonce(count number <span class="keyword">of</span> <span class="keyword">using</span> the account);balance;
    * smart contract account: nonce(count number <span class="keyword">of</span> transaction);balance;storageRoot(datastructure:<span class="type">MPT</span>);codeHash
    * three tries local 
        * state trie
        * transaction trie
        * receipt trie
    * structure <span class="keyword">in</span> three tries 
        * data storage <span class="keyword">in</span> (key,value)
        * state trie:key - address <span class="keyword">of</span> ethereum;<span class="number">160</span> bits; value - <span class="type">RLP</span>(nonce;balance;storageRoot;codeHash)
        * <span class="type">MPT</span> <span class="keyword">and</span> bloom filter.
    * <span class="type">Some</span> <span class="type">Terminology</span>
        * <span class="type">MPT</span>:<span class="type">Merkle</span> <span class="type">Patricia</span> <span class="type">Tree</span>/<span class="type">Trie</span>(compressed hash <span class="type">pointer</span> retrieval)
        * <span class="type">RLP</span>：<span class="type">Recursive</span> <span class="type">Length</span> <span class="type">Prefix</span>(<span class="keyword">method</span> <span class="keyword">of</span> <span class="type">Serialization</span>:nested <span class="type">array</span> <span class="keyword">of</span> bytes)
* <span class="type">Possible</span> <span class="type">Attack</span>
    * <span class="type">Re</span>-entrancy <span class="type">Attack</span>: clear state first!
* ref1: https://github.com/ethereum/wiki/wiki/<span class="type">White</span>-<span class="type">Paper</span>
* ref2: https://ethereum.github.io/yellowpaper/paper.pdf
* ref3: https://solidity.readthedocs.io/en/v0.<span class="number">4</span>.<span class="number">24</span>/index.html
</code></pre><h2 id="cosmos">cosmos</h2><pre><code>* Why cosmos?
    * Goal <span class="operator">of</span> cosmos: solve <span class="operator">the</span> prolem <span class="operator">of</span> application <span class="operator">of</span> high speed transaction <span class="operator">and</span> high throughout.
    * Bitcoin 
        * disadvantage1: Script language - Scrypt cannot <span class="built_in">do</span> complex thing,such <span class="keyword">as</span> decentralized predict market.
        * disadvantage2: speed <span class="operator">of</span> handle transaction is slow: about <span class="number">7</span> txs/<span class="keyword">second</span>.
    * Ethereum 
        * disadvantage1: Solidity language is apt <span class="built_in">to</span> have mistakes <span class="operator">and</span> being attacked.
        * disadvantage2: speed <span class="operator">of</span> handle transaction is slow: about <span class="number">15</span> txs/<span class="keyword">second</span>.
        * disadvantage3: smart contract is hard <span class="built_in">to</span> upgrade.
* Tendermint: Cosmos consensus algorithm (ref <span class="keyword">https</span>://github.com/tendermint/tendermint)
    * Goal <span class="operator">of</span> Tendermint: born <span class="operator">in</span> <span class="number">2014</span>, <span class="built_in">to</span> solve <span class="operator">the</span> problem <span class="operator">of</span> speed, scalability <span class="operator">and</span> enrvironment <span class="operator">of</span> PoW consensus.
    * Idea <span class="operator">of</span> Tendermint 
        * Add Validator,voting power(<span class="operator">in</span> <span class="operator">a</span> PoS application such <span class="keyword">as</span> <span class="operator">the</span> Comos Hub,<span class="operator">the</span> voting power may be determined <span class="keyword">by</span> <span class="operator">the</span> amount <span class="operator">of</span> staking tokens bonded <span class="keyword">as</span> collateral)
        * Resist sybil attack <span class="keyword">using</span> Pledge(locked <span class="operator">in</span> blockchain <span class="keyword">system</span>).
        * Vote: Propose,Prevote,Precommit,Commit,NewHeight
    * Feature <span class="operator">of</span> Tendermint
        * application-agnostic: every Blockchain can use.
        * BFT: Byzantine Fault Tolerance.
        * resist sybil attack <span class="keyword">using</span> PoS algorithm.
    * Differences compared <span class="built_in">to</span> Satoshi Nakamoto consensusm,ethash consensus
        * Probability <span class="operator">of</span> being <span class="operator">the</span> canonical chain is <span class="number">100</span>% instead <span class="operator">of</span> high probability.
        * Fixed Validators instead <span class="operator">of</span> <span class="built_in">variable</span> validators.
        * Fixed proposal instead <span class="operator">of</span> no proposal
        * Fixed timeout mechanism
        * disadvantage1: temporary validators cannot be permitted <span class="built_in">to</span> quit <span class="operator">or</span> enter.
        * disadvantage2: <span class="keyword">system</span> shuold maitain <span class="operator">a</span> same timing <span class="keyword">system</span>
    * performance <span class="operator">of</span> Tendermint
        * block <span class="built_in">time</span> can be <span class="number">1</span> <span class="keyword">second</span>, speed <span class="operator">of</span> transaction: <span class="number">1000</span>txs/<span class="keyword">second</span>
        * Finality is immediate <span class="keyword">if</span> there is less than <span class="number">1</span>/<span class="number">3</span> validators <span class="operator">in</span> <span class="keyword">system</span>.
* Inter Blockchain Communication(IBC)
    * The Hub <span class="operator">and</span> zones communicate <span class="operator">with</span> <span class="keyword">each</span> other. 
    * To move <span class="operator">a</span> packet <span class="built_in">from</span> <span class="constant">one</span> blockchain <span class="built_in">to</span> another:
        * <span class="operator">a</span> proof is posted <span class="command"><span class="keyword">on</span> <span class="title">the</span> <span class="title">receiving</span> <span class="title">chain</span>. </span>
        * The proof states that <span class="operator">the</span> sending chain published <span class="operator">a</span> packet <span class="keyword">for</span> <span class="operator">the</span> alleged destination. 
        * For <span class="operator">the</span> receiving chain <span class="built_in">to</span> check this proof, <span class="keyword">it</span> must be able keep up <span class="operator">with</span> <span class="operator">the</span> sender’s block headers. 
        * This mechanism is similar <span class="built_in">to</span> that used <span class="keyword">by</span> sidechains, which requires <span class="constant">two</span> interacting chains <span class="built_in">to</span> be aware <span class="operator">of</span> <span class="constant">one</span> another via <span class="operator">a</span> bidirectional stream <span class="operator">of</span> proof-<span class="operator">of</span>-existence datagrams (transactions).
    * The IBC protocol can naturally be defined <span class="keyword">using</span> <span class="constant">two</span> types <span class="operator">of</span> transactions: 
        * IBCBlockCommitTx transaction: allows <span class="operator">a</span> blockchain <span class="built_in">to</span> prove <span class="built_in">to</span> <span class="keyword">any</span> observer <span class="operator">of</span> its most recent block-hash.
        * IBCPacketTx transaction: allows <span class="operator">a</span> blockchain <span class="built_in">to</span> prove <span class="built_in">to</span> <span class="keyword">any</span> observer that <span class="operator">the</span> given packet was indeed published <span class="keyword">by</span> <span class="operator">the</span> sender’s application, via <span class="operator">a</span> Merkle-proof <span class="built_in">to</span> <span class="operator">the</span> recent block-hash.
* Application Blockchain Interface (ABCI) 
    * Blockchains are systems <span class="keyword">for</span> multi-master state machine replication. ABCI is <span class="operator">an</span> interface that defines <span class="operator">the</span> boundary between <span class="operator">the</span> replication engine (<span class="operator">the</span> blockchain), <span class="operator">and</span> <span class="operator">the</span> state machine (<span class="operator">the</span> application). Using <span class="operator">a</span> <span class="built_in">socket</span> protocol, <span class="operator">a</span> consensus engine running <span class="operator">in</span> <span class="constant">one</span> <span class="built_in">process</span> can manage <span class="operator">an</span> application state running <span class="operator">in</span> another.
    * ABCI allows <span class="keyword">for</span> blockchain applications <span class="built_in">to</span> be programmed <span class="operator">in</span> <span class="keyword">any</span> language, <span class="operator">not</span> just <span class="operator">the</span> programming language that <span class="operator">the</span> consensus engine is written <span class="operator">in</span>. 
    * Additionally, ABCI makes <span class="keyword">it</span> possible <span class="built_in">to</span> easily swap out <span class="operator">the</span> consensus layer <span class="operator">of</span> <span class="keyword">any</span> existing blockchain stack.
    * Example <span class="operator">of</span> Bitcoin: <span class="operator">the</span> ABCI application would be responsible <span class="keyword">for</span>
        * Maintaining <span class="operator">the</span> UTXO database
        * Validating cryptographic signatures <span class="operator">of</span> transactions 
        * Preventing transactions <span class="built_in">from</span> spending non-existent funds 
        * Allowing clients <span class="built_in">to</span> query <span class="operator">the</span> UTXO database
    * ref <span class="keyword">https</span>://github.com/tendermint/abci

* ref1: <span class="keyword">https</span>://cosmos.network/cosmos-whitepaper.pdf
* ref2: <span class="keyword">https</span>://ethfans.org/posts/how-does-cosmos-work-part1
</code></pre><h2 id="consensus">consensus</h2><pre><code>* Proof-of-Work(PoW)
    * Disadvantage
        * energe: electric power is wasted.
        * mining pool: decentralization is changing to centralization.
* Proof-of-stake(PoS) 
    * What is Proof of stake(PoS)?
        PoS is a method of securing a cryptocurrency network through requesting users to <span class="operator"><span class="keyword">show</span> ownership <span class="keyword">of</span> a certain amount <span class="keyword">of</span> currency.
    * Idea
        * <span class="keyword">add</span> validators(token <span class="keyword">as</span> pledge:determine the probability <span class="keyword">of</span> chosen <span class="keyword">as</span> validator)
        * mining block <span class="comment">---&gt; Minting/Forging</span>
    * advantages
        * cheap:decentralization
        * electric <span class="keyword">power</span> <span class="keyword">is</span> less
    * disadvantages
        * <span class="number">51</span>% attack: richer man become richer. Solve <span class="keyword">by</span>:froze currency used <span class="keyword">for</span> <span class="keyword">choose</span> validator <span class="keyword">for</span> <span class="keyword">some</span> <span class="keyword">time</span>.
        * refuse <span class="keyword">to</span> be a validator. Solved <span class="keyword">by</span>: <span class="keyword">choose</span> more validators.
    * ref: https://en.bitcoinwiki.org/wiki/Proof-<span class="keyword">of</span>-stake
* Delegated Proof <span class="keyword">of</span> Stake (DPoS) 
    * Whast <span class="keyword">is</span> DPoS?
        * DPoS <span class="keyword">is</span> a consensus algorithm developed <span class="keyword">to</span> secure a blockchain <span class="keyword">by</span> ensuring representation <span class="keyword">of</span> transactions within it.
        * DPoS <span class="keyword">is</span> designed <span class="keyword">as</span> an implementation <span class="keyword">of</span> technology-based democracy, <span class="keyword">using</span> voting <span class="keyword">and</span> election process <span class="keyword">to</span> protect blockchain <span class="keyword">from</span> centralization <span class="keyword">and</span> malicious <span class="keyword">usage</span>.
    * advantages
        * DPoS coins <span class="keyword">are</span> much more scalable than <span class="keyword">POW</span> cryptocurrencies <span class="keyword">as</span> they never <span class="keyword">start</span> requiring high computing <span class="keyword">power</span> <span class="keyword">and</span> <span class="keyword">are</span> generally approachable <span class="keyword">for</span> users <span class="keyword">with</span> poor equipment.
        * DPoS blockchains showed themselves <span class="keyword">to</span> be faster than <span class="keyword">PoW</span> <span class="keyword">and</span> PoS-based blockchains.
        * DPoS coins <span class="keyword">are</span> more democratic <span class="keyword">and</span> inclusive than their alternatives. DPoS vs PoS offers more governance <span class="keyword">power</span> <span class="keyword">to</span> users <span class="keyword">with</span> small stakes, * DPoS vs <span class="keyword">PoW</span> does <span class="keyword">not</span> require <span class="keyword">as</span> much computing <span class="keyword">power</span> <span class="keyword">and</span>, therefore, <span class="keyword">is</span> <span class="keyword">not</span> so financially demanding <span class="keyword">on</span> the <span class="keyword">user</span>.
        <span class="keyword">As</span> threshold <span class="keyword">to</span> enter <span class="keyword">is</span> very low, DPoS <span class="keyword">is</span> largely considered <span class="keyword">to</span> be the most decentralized approach <span class="keyword">to</span> consensus mechanism.
        * DPoS <span class="keyword">is</span> energy efficient <span class="keyword">and</span> environmentally friendly.
        * DPoS networks have strong protection <span class="keyword">from</span> <span class="keyword">double</span> spend attack.
    * disadvantages
        * Successful existence <span class="keyword">of</span> the network requires participation <span class="keyword">and</span> coordination <span class="keyword">of</span> genuinely interested community <span class="keyword">for</span> effective governance <span class="keyword">of</span> the panel <span class="keyword">of</span> witnesses <span class="keyword">by</span> voting them <span class="keyword">in</span> <span class="keyword">and</span> out.
        * DPoS systems <span class="keyword">are</span> vulnerable <span class="keyword">to</span> centralization <span class="keyword">as</span> a <span class="built_in">number</span> <span class="keyword">of</span> witnesses <span class="keyword">is</span> strictly limited.
        * DPoS blockchain <span class="keyword">is</span> exposed <span class="keyword">to</span> flaws <span class="keyword">of</span> classic <span class="built_in">real</span>-life voting. <span class="keyword">For</span> example, DPoS users <span class="keyword">with</span> small stakes can decide that their vote doesn<span class="string">'t matter in comparison with votes of bigger stakeholders.
* ref1: https://zh.wikipedia.org/wiki/%E5%85%B1%E8%AD%98%E6%A9%9F%E5%88%B6</span></span>
</code></pre>]]></content>
      
        <categories>
            
            <category> 区块链 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 区块链 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[我的随笔]]></title>
      <url>/2019/11/06/%E6%88%91%E7%9A%84%E9%9A%8F%E7%AC%94/</url>
      <content type="html"><![CDATA[<h2 id="爱一个人_2007-12_/_2020-02-02">爱一个人 2007-12 / 2020-02-02</h2><p>爱一个人就要爱他的全部<br>从头发到灵魂<br>深深的理解他<br>并接受他</p>
<h2 id="希望_2020-01-30">希望 2020-01-30</h2><p><code>晚上看完《Joker》，想起了很多感受和回忆。脑海中的经历就冒出了这样几句话，虽然很短，却句句沉重。</code></p>
<p>在奔跑的过程中，难免迷失在森林中<br>不知不觉的，跌入黑暗<br>在黑暗中，仿佛无法获得勇气和力量<br>慢慢的，连感受都无法感受<br>而冥冥中，不知道从哪里来的勇气和力量<br>敲开了一点亮光<br>这道光是上帝，是佛祖，是无穷的希望<br>带领着走向那片平原<br>蓦然回首，发现黑暗中<br>自己在狡黠的眨眼</p>
<h2 id="脑海中的跳跃_2019-11-06">脑海中的跳跃 2019-11-06</h2><p>可怕的景象叠加在现实的光线中<br>忐忑下一秒的时光是否安全<br>仿佛下一个镜头就是坠入深渊<br>却幻想那是飞跃沟壑的跳板<br>断了联结<br>摇曳飘荡<br>挑战？机会？是否还有希望<br>是啊！希望总是孕育在剧烈的失望之中<br>放弃虚伪的假象<br>迎接真实<br>尽管疼痛，尽管无法安慰，尽管不像化学合成的饮料那样甜香<br>将心放在心上<br>这就是生命应该的姿态</p>
<h2 id="修心_2017-04-30_20:15:00">修心 2017-04-30 20:15:00</h2><p>  在人生的漫漫旅途中，我经常思考的是：什么才是重要的而需要把握的，什么是应该放下甚至放弃的，如何做到轻松放下，淡定从容？</p>
<p>  五一劳动节，二零一七年。劳动者的节日，这是一个应该庆祝的日子，正是因为劳动，才带来了工具，才产生了人类文明。而浩瀚的人类文明长河中，中国传统文化给人带来了很多值得深思的东西。中国传统文化中最核心的一个词，就是修心。</p>
<p>  朗读者有一期节目，讲的是秋歌和秋雨的故事，这是一对双胞胎，而命运多舛，他们患上了严重的自闭症，治疗之路艰难而漫长，偏偏祸不单行，秋歌同时患上了白血病，长期化疗带来的不仅仅是孩子的痛苦，更难以忍受的是父母那颗无法直视孩子受痛苦折磨的心啊！</p>
<p>  还有，一个大山里的孩子，因为家里的变故不得不休学一年，孩子遇到了一位好老师，轻轻的拍着孩子的肩膀，告诉他：“明年，到我这里复学。” 这个孩子叫陈忠实，一位杰出的作家。</p>
<p>  中国每天约1万人被确诊患上癌症，而癌症死亡率大约1／7即每天全中国有1400多人死于癌症。当然，还有车祸，其他疾病，各种意外夺走很多人的生命，破坏着那么多的家庭。</p>
<p>  这个世界上没有新鲜事，只是你没有真正经历，没有深刻体会而已。</p>
<p>  对于这个世界，我能想到的最正确的态度，应该是：“敬畏”。你没有理由不敬畏自然，一场地震就夺走成千上万人的生命。你没有理由不敬畏社会，社会的规则会让你知道什么才是真正的公平。你没有理由不敬畏你所处的工作，这是你和家人的经济和价值来源。你没有理由不敬畏周围的人，他们看上去可能平凡或者自大，傲娇或者谦虚，讨人厌或者招人爱，他们都有自己人生的成长经历，每个人都有其值得学习的地方。</p>
<p>  敬畏这个世界，更重要的是敬畏自己。从某种意义上讲，每个人都是独一无二的生命奇迹。要敬畏自己，就是要正确面对自己内心的善与恶。人之初，性本善。保护好自己应有的善良，才能发现更多的美。直面自己内心的恶，才能真正做到自知之明，人是复杂的多面体，从任何一个角度折射出来的影子都是真相的一方面，而已。</p>
<p>  修心，不是一句空话，要做的事情很多。读书，读的是作者做事做人的态度和哲学。实践，是将自己的做人处事哲学融会贯通到自己的周遭中去。</p>
<p>  你的遭遇有多糟？想想秋歌的父母，想想大山的孩子，你的心是不是就平和了一些，真正的平和才能让你继续前进。这就是修心。</p>
<p>  推己及人，当你遇到同样遭遇的人，你的同情心能否让你更多的帮助别人，相信你收获的更多。有一次，路过安河桥北小路的路口，一对夫妻过马路，我很远就减速，示意他们先过，女士展现出了真诚的微笑，还伸了大拇指，这让我在开心了很久，你说，我是不是赚到了？这就是修心。</p>
<p>  更多的时候，你无法控制你野马一样的坏情绪，口无遮拦，伤人无数，包括自己。那么，请静下来，深呼吸，读读书，劳动一下。正如那位居士所言，得道之前，我是砍柴，挑水，做饭，得道之后，我还是砍柴，挑水，做饭。差别在于：得道之前，我砍柴时想着挑水，挑水时想着做饭，得道之后，我砍柴时就想着砍柴，挑水时就想着挑水，做饭时就想着做饭。有时候，道理都是简朴至极的。</p>
<p>  读万卷书，行万里路，做不到阅人无数，至少可以做到和自己和平相处。什么是重要的？什么是可以把握的？如何做到轻松放下？我想都和你自己的那颗心有关。</p>
<h2 id="谈谈苟且的理想_2017-06-20_15:29:00">谈谈苟且的理想 2017-06-20 15:29:00</h2><p>理想，真的只是高大上的存在，官僚的说辞吗？当然不是，理想应该正名！</p>
<p>  在当今中国的大地上，我不知道还有多少人面临着各种各样的痛苦，刚从知乎的帖子上看到计划生育政策强制让七个月大的孩子引产，简直泯灭人性！当你想改变这一切时，你内心的理想是否要蓬勃而出？为人类的解放而奋斗！这真不是口号，而是内心的声音。</p>
<p>  坚持又是另外一回事，当你离开那个情绪，离开那个片段，你又感受到房子的压力，单位的待遇，发展的瓶颈时，你自我利益的小人又开始躁动，这些其实都是信息流逐渐获取对我们的控制权的表现，信息带着各种观点，揉杂着好奇和迎合，让我们陷入信息的洪流，不停的打旋，无法自拔。</p>
<p>  该怎么拯救苟且的理想？首先要面对自己，打开心胸，承认自己的过错，原谅自己，修正自己。接下来，把内心的垃圾扔出去，看看自己都变成什么了？精致的利己主义者还是虚无的犬儒主义者。不管自己变成了什么，看看自己到底是不是希望的那样。如果不是，改变自己。然后就简单了，你内心敞亮了，容纳进新的好的东西比如理想的时候，慢慢的放进去，调整好位置，让它舒服的躺在你内心里的沙发上，微笑着看心花怒放。</p>
<p>  静下来想想，人生的时间总不能都浪费在纠结和彷徨中，那就找到自己的理想，当今中国有那么多值得做的事情，找一件事情，把它做好，也就不枉此生了吧。</p>
<p>  所以，理想绝对不能苟且的躺在情绪波动的缝隙中！要把它拿出来，抖擞精神，太阳下晒干，蒸发细菌，清新自然。</p>
<p>  苟且的理想，是我们呆在自己的小小瓶子里，内心偶尔发出的微小声响。顺着线索找到它，比如降低中国的交通事故：研发汽车中的自动安全防护系统（Volvo已经做了很好的产品），提高自动驾驶的安全技术，创新管理加强法制建设。比如，消除国人内心的焦虑感：提高文化产品，加大文化输出，提高国人的精神归属感和凝聚力，做优秀的文化产品，做有价值的公益事业（帮助心理疾病患者克服心理障碍）。比如，做父亲后，对于孩子的一丝痛苦都会放大很多倍，如何让孩子健康成长，可以做很多免费公益课，加强幼儿教育水平，给孩子一个科学而健康的童年教育，保护每个孩子的好奇心，让他们自由呼吸，不被俗世的框框所束缚。</p>
<p>  你以为你没有理想？你有，只是你听不到，因为外面的噪音就像山洪爆发，地震袭来一样，你静不下来，更听不到那一丝内心的声音。所以，建议每天给自己半个小时，和自己聊聊天，谈谈你的理想，你为自己的理想做了什么，还能做什么，做到了多少。我相信，你会越来越热爱你自己的！也只有这样，等你面对人生的无常，生命的消逝时，你回忆往事，你还能会心一笑。因为你知道，多年的坚持是值得的，那苟且的理想，并没有关在笼子里，已经开始飞翔！</p>
<h2 id="给无缘人_2018-01-17_19:45:00">给无缘人 2018-01-17 19:45:00</h2><p>你付出的真心</p>
<p>我本无意辜负</p>
<p>年轻而无知的人啊</p>
<p>但愿，那些真心</p>
<p>都在未来的树枝上</p>
<p>开出美丽的花朵</p>
<h2 id="如何追求你想要的人生_2017-07-07_17:31:00">如何追求你想要的人生 2017-07-07 17:31:00</h2><p>每个人都是独一无二的。追求往往是徒劳。做自己最重要</p>
<p>在这个世界上，没有一件东西是完全一样的，当然也包括人自己。每个人都是大自然的艺术品，充满灵性，独一无二。</p>
<p>首先你要清楚的认识你自己。</p>
<p>其次，所谓抓得越紧越是徒劳。真正有效的方法是：塑造你自己，无论是设定目标抑或寻找榜样，把自己打造成配得上那种人生的人的模样。</p>
<p>最后，做自己最重要。模仿只是模仿，自己的特色才能让你真正成为你自己。</p>
<p>认知决定你的高度，视野决定你的广度，忘记追求，做最好的自己，其实你的人生就是你想要的！</p>
<h2 id="人生的架构图_2017-07-21_11:39:00">人生的架构图 2017-07-21 11:39:00</h2><p>人生的道路其实也不过如此，最重要的是了生死，知自己，不要自我设限。</p>
<p><img src="了生死.png" alt="了生死"></p>
]]></content>
      
        <categories>
            
            <category> 写作 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[我的笔记]]></title>
      <url>/2017/09/22/%E6%88%91%E7%9A%84%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h2 id="电影笔记">电影笔记</h2><ul>
<li>《82年生的金智英》2020-02-02<br><a href="https://movie.douban.com/subject/30327842/" target="_blank" rel="noopener">82年生的金智英 豆瓣链接</a><ul>
<li>重男轻女带来的不仅是损害家庭伦理，更是伤害了很多人，包括生命和人生</li>
<li>勇于做自己是勇敢的表现</li>
<li>同理心是处理人和他人关系的key</li>
</ul>
</li>
</ul>
<ul>
<li>《Joker》<br><a href="https://movie.douban.com/subject/27119724/" target="_blank" rel="noopener">JOKER 豆瓣链接</a><ul>
<li>压抑的愤怒，如果没有适当的表达出口将会导致可怕的麻木和暴力。对个人如此，对社会如此，对人类也是如此。</li>
<li>人和自己的关系：当没有人注意你，在乎你，尊重你的时候，当有人欺负你的时候，你要尊重，在乎，注意你自己。</li>
<li>面具下的虚伪是这个世界的毒药。</li>
<li>Always look at the bright side。这个世界一定不完美，再丑恶的人或事都有积极的方面，注意那些积极的方面，才能形成正循环，不断向上。</li>
</ul>
</li>
</ul>
<ul>
<li><p>《The Post》<br><a href="https://movie.douban.com/subject/26990609/" target="_blank" rel="noopener">豆瓣链接</a></p>
<ul>
<li>国家不是总统一个人的，而是全体人民的。</li>
<li>公民社会任重道远。</li>
</ul>
</li>
<li><p>《Life of PI》<br><a href="https://movie.douban.com/subject/1929463/" target="_blank" rel="noopener">豆瓣链接</a></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Above all, Don&apos;t lose hope.</span><br><span class="line"></span><br><span class="line">我们共处一个环境，虽然不能做朋友，但我们可以学会沟通。</span><br><span class="line"></span><br><span class="line">Without Richard parker, I would have died by now.</span><br><span class="line"></span><br><span class="line">It&apos;s beautiful.</span><br><span class="line"></span><br><span class="line">It happened. Why should it have to mean anything?</span><br></pre></td></tr></table></figure>
<p>My Thinking:</p>
<ul>
<li>我们都处在不同的关系中：亲密关系，陌生人关系，和自己的关系，和自然的关系。</li>
<li>在和自然的关系中，事实重于意义，沟通大于征服，不能做朋友但可以共存，这种关系很真实，看上去残酷实际上却很仁慈。（野性也许更仁慈）</li>
<li>语言有时候是虚伪的，那些行动和眼神才是真诚而令人动容的。</li>
</ul>
<ul>
<li>《The Professor》<br><a href="https://movie.douban.com/subject/27040157/" target="_blank" rel="noopener">豆瓣链接</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">你们已经是世界上的濒危物种了，我恳求你们，不要选择平庸，不要碌碌无为，就像这个世界上其他的98%的人那样，因为这个世界已经满目疮痍，你们必须靠你们自己，珍惜每一分每一秒，珍惜每一口呼吸，生活，其实就是一段鸟鸣。</span><br></pre></td></tr></table></figure>
<p>My Thinking:</p>
<ul>
<li>Live as if you will die tommorow.</li>
<li>《Alita: Battle Angel》</li>
</ul>
<ul>
<li>阿丽塔：战斗天使 Alita: Battle Angel (2019)<br><a href="https://movie.douban.com/subject/1652592/" target="_blank" rel="noopener">豆瓣链接</a></li>
</ul>
<p>My Thinking:</p>
<ul>
<li>What am I? Brain, Memory, Desire? Free Will? 真正决定我是我自己的，是我的躯体吗？阿丽塔换一个身体好像还是阿丽塔，那么是我的大脑或者我的记忆吗？也许是的，大脑是关键的，而大脑中什么是最核心的呢？也就是什么才是决定我是我自己呢？耶鲁大学的雪莱有公开课谈论过这个问题。我想当我的身体可以被机器取代，那有没有一天我的大脑也可以被取代？那一天也许是人类的技术巅峰到达之时，也是人类毁灭之日。</li>
<li>人性？ 不要被外表所迷惑，无论ta是组装人还是别的东西，人性的光芒来自于对自然中的生命的同情和理解，比如那条狗，比如男主，比如悬赏猎人养狗人。</li>
<li>制度？ 监视，控制和巨大的阶级鸿沟。 这也许才是最大的恶？或者每个人的角度不同，也许是最大的善？ 需要问的则是：存在的基础是否合理，思想基础是什么？</li>
</ul>
<p>*《Solaris》<br><a href="https://zh.wikipedia.org/wiki/%E7%B4%A2%E6%8B%89%E9%87%8C%E6%96%AF%E6%98%9F_(1972%E5%B9%B4%E7%94%B5%E5%BD%B1" target="_blank" rel="noopener">Wiki链接</a>)</p>
<ul>
<li>“在这里，庸人和天才都一样毫无价值，我们没有兴趣征服宇宙，我们想把地球延伸到宇宙的边界…我们不需要宇宙，我们需要一面镜子…人类，需要人类。”</li>
<li>塔可夫斯基通过影片提出两个观点：人类未能处理好自身的问题，就不应当探索外部；或人类应当探索外部，忽略人性。然而哈莉，却提出第三种观点：凯尔文比你们更有人性，而我快变成人了。在<a href="https://zh.wikipedia.org/wiki/冷战" target="_blank" rel="noopener">冷战</a>时代，他面临的问题是严峻的对人的拷问，在这种情形下，人对外界的探索能力丧失意义，导演回到了人类本身。 </li>
</ul>
<p>My Thinking:</p>
<ul>
<li>人类关注自己，先把自己安顿好。就像爱别人先学会爱自己。<br>*《巴斯特·斯克鲁格斯的歌谣 The Ballad of Buster Scruggs (2018)》</li>
</ul>
<ul>
<li><p>巴斯特·斯克鲁格斯的歌谣 The Ballad of Buster Scruggs (2018)<a href="https://movie.douban.com/subject/26952704/" target="_blank" rel="noopener">豆瓣链接</a></p>
<ul>
<li>科恩兄弟的作品。充满了想象力和对内心深处和生命本质的探索，让我很受用。</li>
<li>人的生命是一条通往目的地的马车，从不停歇。</li>
<li>人生无常，其实意外并不意外。</li>
</ul>
</li>
<li><p>《波西米亚狂想曲 Bohemian Rhapsody (2018)》2019-11-21 14:49:00<br><a href="https://movie.douban.com/subject/5300054/" target="_blank" rel="noopener">豆瓣链接</a></p>
<ul>
<li>皇后乐队（Queen）主唱Freddie Mercury的传记片。</li>
<li>音乐是人类的通用语言，完美还原现场，we are the champions!</li>
</ul>
</li>
</ul>
<h2 id="研究者方法论（持续更新）2020-02-17">研究者方法论（持续更新）2020-02-17</h2><ul>
<li>引言<br>工欲善其事，必先利其器。受机器学习研究者方法论的刺激，整理下思路，分享之。</li>
<li>成功的关键在于解决正确的问题，并在这些问题上不断取得进步，实现持续的个人成长。（《机器学习研究指南》John Schulman）</li>
<li>挑选要解决的问题<ul>
<li>阅读大量论文，并认真评论与探讨；</li>
<li>成立研究小组，吸收他人研究经验；</li>
<li>找自身研究者提建议，吸收他人的看法；</li>
<li>花时间思考哪些研究能够产出成果；<ul>
<li>理论在什么时候是有用的</li>
<li>实验结果普遍吗</li>
<li>为什么一些方法广泛被采纳，其它又被遗忘</li>
</ul>
</li>
</ul>
</li>
<li>研究工作的驱动类型之一：想法驱动<ul>
<li>这两种方法并不是相互排斥的，任何领域的机器学习的新想法都与某些目标有关。从某种意义上来说，想法驱动的研究就是目标驱动的一部分。</li>
<li>想法驱动的研究有一个缺点，存在被窃取或窃取其它研究工作的风险。</li>
</ul>
</li>
<li>研究工作的驱动类型之二：目标驱动<ul>
<li>将自己定义在通用解决方案中。（great！）</li>
<li>增量研究：在更大的目标下做增量研究（10% 的提升）是最有效的。</li>
</ul>
</li>
<li>专注：研究是一条漫漫长路，在这条路上可能发现新算法、发篇新论文，也可能是直到最后才能知道一个结果。为了在这条旅途中开发新的算法和见解，你需要在很长一段时间内把精力集中在一个问题上。</li>
<li>习惯：保持写笔记的习惯。</li>
<li>“换坑”：根据经验来说，过于频繁地切换想法比呆在原地不动的故障概率更高。不排除会存在具备超强潜力的新想法，但更常见的是失望。</li>
<li>一般性知识的学习<ul>
<li>教材书：一般以一种更集中的方式来吸取知识。</li>
<li>学位论文：除了教材书之外，学位论文的阅读也是必不可少的</li>
<li>阅读其他论文来拓展知识前沿。</li>
<li>除了阅读那些富有创造性的论文并进行复现之外，你也应该关注领域内不那么突出的论文。以批判的眼光浏览阅读即将发表的论文有助于你时刻跟上领域内的发展趋势。</li>
</ul>
</li>
<li>吴恩达的建议（CS230 课程中，对于研究规划与如何读论文也提出了他的一些建议）<ul>
<li>参考视频：CS230 Lecture 8: Career advice / Reading papers：<a href="https://www.youtube.com/watch?v=733m6qBH-jI" target="_blank" rel="noopener">https://www.youtube.com/watch?v=733m6qBH-jI</a></li>
<li>读论文是做研究的基础，高效地读高质量论文又是重中之重。</li>
<li>如果阅读 5-20 篇论文，差不多我们对该领域就有一定的了解了。如果高效阅读 50 到 100 篇论文，那么对该领域的理解就比较完整了。</li>
<li>阅读论文的方法<ul>
<li>第一遍应该只看标题、摘要和图表</li>
<li>第二遍应该继续看前言、结语和图表</li>
<li>第三遍阅读就要纵览论文主体了</li>
<li>第四遍需要阅读所有的内容</li>
</ul>
</li>
</ul>
</li>
<li>团队合作也很重要。</li>
<li><p>工业界交付产品时的一些实用方法和建议：</p>
<ul>
<li>为自己感兴趣的任何项目创建一个工作代码项目文件夹；</li>
<li>如果发现一些有趣或类似于你正在研究的东西，尝试任何已发表的代码；</li>
<li>在运行 Python 的过程中，你可以利用 pyenv 来轻松地避开不同的需求；</li>
<li>如果 repo 起作用，则创建一个标有「起作用」的文件菜单，以方便下次找到；</li>
<li>让自己擅长创建数据集并进行预处理和分类；</li>
<li>收集一些与自己研究类似的数据集；</li>
<li>当更好的代码出现时，要尝试使用；当意识到观点需要改进时，使用已有方法来打磨优化自己的数据集。</li>
</ul>
</li>
<li><p>参考文献</p>
</li>
</ul>
<ol>
<li><a href="https://mp.weixin.qq.com/s/QMDNKC0-sZu5p8LdMIULfg" target="_blank" rel="noopener">机器学习研究者的养成指南，吴恩达建议这么读论文</a></li>
<li>《机器学习研究指南》John Schulman</li>
</ol>
<h2 id="《互联网企业安全高级指南_作者：赵彦_江虎_胡乾威》_读书笔记_2020-02-17">《互联网企业安全高级指南 作者：赵彦 江虎 胡乾威》 读书笔记 2020-02-17</h2><ul>
<li>漏洞扫描、入侵感知和应急响应是技术维度日常工作中最重要的3部分</li>
<li>互联网的安全体系：基本上以运维安全、应用安全、业务安全三管齐下。</li>
<li>推倒业界，社区，甲方，乙方之间有一堵墙，看到企业安全的整体体系。</li>
<li>“二进制”流派和“脚本”流派并不是全部。</li>
<li>企业安全：从广义的信息安全或狭义的网络安全出发，根据企业自身所处的产业地位、IT总投入能力、商业模式和业务需求为目标，而建立的安全解决方案以及为保证方案实践的有效性而进行的一系列系统化、工程化的日常安全活动的集合。涵盖7大领域：<ol>
<li>网络安全：基础、狭义但核心的部分，以计算机（PC、服务器、小型机、BYOD……）和网络为主体的网络安全，主要聚焦在纯技术层面。</li>
<li>平台和业务安全：跟所在行业和主营业务相关的安全管理，例如反欺诈，不是纯技术层面的内容，是对基础安全的拓展，目的性比较强，属于特定领域的安全，不算广义安全。</li>
<li>广义的信息安全：以IT为核心，包括广义上的“Information”载体：除了计算机数据库以外，还有包括纸质文档、机要，市场战略规划等经营管理信息、客户隐私、内部邮件、会议内容、运营数据、第三方的权益信息等，但凡你想得到的都在其中，加上泛“Technology”的大安全体系。</li>
<li>IT风险管理、IT审计&amp;内控：对于中大规模的海外上市公司而言，有诸如SOX404这样的合规性需求，财务之外就是IT，其中所要求的在流程和技术方面的约束性条款跟信息安全管理重叠，属于外围和相关领域，而信息安全管理本身从属于IT风险管理，是CIO视角下的一个子领域。</li>
<li>业务持续性管理：BCM（BusinessContinuityManagement）不属于以上任何范畴，但又跟每一块都有交集，如果你觉得3和4有点虚，那么BCM绝对是面向实操的领域。最近，有网易、中有支付宝、后有携程，因为各种各样的原因业务中断，损失巨大都属于BCM的范畴。有人会问：这跟安全有什么关系？安全是影响业务中断的很大一部分可能因素，例如DDoS，入侵导致必须关闭服务自检，数据丢失，用户隐私泄露等。又会有人问：这些归入安全管理即可，为什么要跟BCM扯上关系，做安全的人可以不管这些吗？答案自然是可以不管，就好像说：“我是个Java程序员，JVM、dalvik（ART）运行原理不知道又有什么关系，完全不影响我写代码！”事实上，BCM提供了另一种更高维度、更完整的视角来看待业务中断的问题。对于安全事件，它的方法论也比单纯的ISMS更具有可操作性，对业务团队更有亲和力，因为你知道任何以安全团队自我为中心的安全建设都难以落地，最终都不会做得很好。</li>
<li>安全品牌营销、渠道维护：CSO有时候要做一些务虚的事情，例如为品牌的安全形象出席一些市场宣介，presentation。笼统一点讲，现在SRC的活动基本也属于这一类。</li>
<li>CXO们的其他需求：俗称打杂。这里你不要理解为让安全团队去攻击一下竞争对手的企业这样负面向的事情，而是有很多公司需要做，但运维开发都不干，干不了或者不适合干的事情，安全团队能力强大时可以承包下来的部分，事实上我的职业生涯里就做了不少这样的事情。</li>
</ol>
</li>
<li>互联网安全的工作：<ol>
<li>信息安全管理（设计流程、整体策略等），这部分工作约占总量的10%，比较整体，跨度大，但工作量不多。</li>
<li>基础架构与网络安全：IDC、生产网络的各种链路和设备、服务器、大量的服务端程序和中间件，数据库等，偏运维侧，跟漏洞扫描、打补丁、ACL、安全配置、网络和主机入侵检测等这些事情相关性比较大，约占不到30%的工作量。</li>
<li>应用与交付安全：对各BG、事业部、业务线自研的产品进行应用层面的安全评估，代码审计，渗透测试，代码框架的安全功能，应用层的防火墙，应用层的入侵检测等，属于有点“繁琐”的工程，“撇不掉、理还乱”，大部分甲方团队都没有足够的人力去应付产品线交付的数量庞大的代码，没有能力去实践完整的SDL，这部分是当下比较有挑战的安全业务，整体比重大于30%，还在持续增长中。</li>
<li>业务安全：上面提到的2），包括账号安全、交易风控、征信、反价格爬虫、反作弊、反bot程序、反欺诈、反钓鱼、反垃圾信息、舆情监控（内容信息安全）、防游戏外挂、打击黑色产业链、安全情报等，是在“吃饱饭”之后“思淫欲”的进阶需求，在基础安全问题解决之后，越来越受到重视的领域。整体约占30%左右的工作量，有的甚至大过50%。这里也已经纷纷出现乙方的创业型公司试图解决这些痛点。</li>
</ol>
</li>
<li>大型互联网企业安全建设的方法论<ul>
<li>自研或对开源软件进行二次开发+无限水平扩展的软件架构+构建于普通中低端硬件之上（PC服务器甚至是白牌）+大数据机器学习的方式，是目前大型互联网公司用来应对业务持续增长的主流解决方案。（机器学习阶段还不确定，但安全大数据时代已经到来）</li>
<li>注意：安全架构随着整个业务架构水平扩展，保证高可用性。</li>
</ul>
</li>
<li>生态级企业vs平台级企业安全建设的需求<ul>
<li>质的差别：生态级：大部分自研；平台级：开源或者商业软件+一部分自研。</li>
<li>例子：Google造轮子Android；阿里的ODPS；华为的LiteOS。</li>
<li>原因：<ul>
<li>技术驱动还是应用层驱动。<ul>
<li>生态级：技术驱动（自己造轮子），安全覆盖基础架构和应用层面；</li>
<li>平台级：应用驱动，安全围绕应用层面。</li>
</ul>
</li>
<li>钱：成本；ROI。“为什么从事信息安全行业一定要去大公司”-知乎</li>
<li>人：大牛成本高，来了也不一定能有用武之地。<ul>
<li>平台级的知识和经验集中在：Web/App，应用层协议，Web容器，中间件和数据库。</li>
<li>生态级的知识和经验集中在：二进制，运行时环境和内核级别。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>平台级公司的技术发展天花板<ul>
<li>修改SSHD，LVS，加入一些安全特性，定制一个WAF，日志的大数据分析。</li>
<li>不介入：DPI，全流量入侵检测，SDN，内核级别的安全机制。</li>
</ul>
</li>
<li>生态级公司的竞技场<ul>
<li>入侵检测，WAF，扫描器，抗DDoS，日志分析。</li>
<li>在SDL环节上自研，但短平快。</li>
<li>一个原则：自研工具只限定在“民用”领域，不会设计RSA算法这类的。</li>
</ul>
</li>
<li>云计算的本质是改变企业需求方通过传统的渠道获取IT资源的方式。</li>
<li>治病还是救火是有区别的。体现在安全建议的差别上。</li>
<li>甲方安全建设CSO的工作<ul>
<li>第一张表：组织结构图；第二张表：每一个线上产品（服务）和交付团队（包括其主要负责人）的映射。第三张表：全网拓扑、各系统的逻辑架构图、物理部署图、各系统间的调用关系、服务治理结构、数据流关系。</li>
<li>初期三件事：1 事前的安全基线 2 事中的监控能力，多维度的入侵检测 3 事后的应急响应，应急的时间成本更短，溯源和根因分析的能力更强。</li>
<li>安全需要向业务妥协吗？<ul>
<li>安全的本质是风险管理-Fireeye这样的公司也一样会被APT</li>
<li>安全建设的本质是以一定的成本追求最大的安全防护效果</li>
<li>风险缓解的原则是在以下三者之间做最大平衡：<br>1 风险暴露程度 2 研发运维变更成本 3 用户体验的负面影响</li>
<li>亚马逊Amazon有一个研发理论：T-shirt Size估计的方式来做项目。比如：当业务影响力是XL，时间人员成本是S，这是最高优先级。<a href="https://coolshell.cn/articles/10217.html#more-10217" target="_blank" rel="noopener">加班与效率</a></li>
</ul>
</li>
</ul>
</li>
<li>需要自己发明安全机制吗？<ul>
<li>安全机制：常见的对称和非对称加密算法，操作系统自带的BRAC基于角色的访问控制，自带的防火墙Netfilter，Android的基于appid隔离的机制，Kernel支持的DEP（数据执行机构），以及各种ASLR，各种安全函数、服务器软件的安全选项。比如三星的KNOX就是在Android基础上自己造的轮子。</li>
<li>日常中发生的问题绝大多数问题都属于对现有安全机制的理解有误、没有启用或没有正确使用安全机制而导致的漏洞，而不是缺少安全机制，所以绝大多数场景不需要发明安全机制。</li>
<li>判断是否是一个问题还是一类问题<ul>
<li>一类问题的情况，分以下情况<ul>
<li>安全编程能力不足：不需要导入新机制，通过加强SDL的某些环节，加强培训教育取解决。</li>
<li>在相应的领域还没有成熟的安全解决方案，或者现有的安全机制对抗程度太弱：则可以考虑自己造轮子。</li>
</ul>
</li>
</ul>
</li>
<li>安全工程师晋升为Leader很重要的一点：对安全事件和安全漏洞的抽象能力，没有抽象就谈不上PDCA。</li>
</ul>
</li>
<li>如何看待SDL（安全开发生命周期）<ul>
<li>基本软件安全培训的基础概念<ul>
<li>安全设计<ul>
<li>减小攻击面</li>
<li>深度防御</li>
<li>最小权限原则</li>
<li>安全默认配置</li>
</ul>
</li>
<li>威胁建模<ul>
<li>威胁建模概述</li>
<li>威胁模型的设计意义</li>
<li>基于威胁模型的编码约束</li>
</ul>
</li>
<li>安全编码<ul>
<li>缓冲区溢出（C/C++）</li>
<li>整数算法错误（C/C++）</li>
<li>跨站点脚本（托管代码和web应用程序）</li>
<li>SQL注入</li>
<li>弱加密</li>
</ul>
</li>
<li>安全测试<ul>
<li>安全测试和功能测试的区别</li>
<li>风险评估</li>
<li>安全测试方法</li>
</ul>
</li>
<li>隐私<ul>
<li>隐私敏感数据的类型</li>
<li>隐私设计最佳实践</li>
<li>风险评估</li>
<li>隐私开发最佳实践</li>
<li>隐私测试最佳实践</li>
</ul>
</li>
<li>高级概念培训，包括但不限于以下方面<ul>
<li>高级安全设计和体系结构</li>
<li>可信用户界面设计</li>
<li>安全漏洞细节</li>
<li>实施自定义威胁缓解</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>简单的流程+实践驱动型构成了日常行为的本质</li>
<li>Facebook宣称：最好的程序员投入在工具研发上</li>
<li>互联网安全的主要瓶颈还是人和工具的缺失。</li>
<li>STRIDE威胁建模<ul>
<li>Spoofing假冒</li>
<li>Tampering篡改</li>
<li>Repudiation否认</li>
<li>Information Disclosure信息泄漏</li>
<li>Denial of service拒绝服务</li>
<li>Elevation of Privilege权限提升</li>
</ul>
</li>
<li>数据流关系图DFD，包含四个元素：数据流、数据存储、进程和交互方，对于威胁建模，增加一个元素即信任边界。</li>
<li>STRIDE有助于风险识别的覆盖面。</li>
<li>标准的作用：救火阶段之后，企业的安全建设哪些事情是值得做的。</li>
<li>实用的参考<ul>
<li>ITIL(BS15000/ISO20000)—-绝大多数互联网公司的运维流程都是以ITIL为骨架建立的。</li>
<li>SDL—-研发测的安全管理，绝大多数公司都借鉴了微软的SDL，所以无论如何要掌握它。</li>
<li>ISO27001—-企业安全管理领域的基础性安全标准。最精简的了，入门级。</li>
</ul>
</li>
<li>业务持续管理BCM-较高层次的管理机制 <ul>
<li>总体目标：提高企业的风险防范能力，有效的响应非计划的业务破坏并降低不良影响。</li>
<li>重要环节<ul>
<li>BIA(Business Impact Analysis)业务影响分析（和基于资产权重的风险管理方法类似，和威胁建模异曲同工）</li>
<li>Recovery Strategy恢复策略</li>
<li>实施以及测试和演练</li>
<li>BCP-Business Continuity Plan</li>
</ul>
</li>
<li>应急响应<ul>
<li>PDCERF模型（也可以参考NISTSP800-61）</li>
</ul>
</li>
<li>评价安全建设做的的好坏的唯一标准：ROI，用什么样的资源TCO产出什么样的安全效果。</li>
<li>技术篇-防御架构原则<ul>
<li>防守体系建设三部曲<ul>
<li>攻防对抗的三个层面的对抗：信息对抗、技术对抗、运营能力对抗。</li>
<li>高纬防守。扭转攻防优势的手段：HIDSAPI hook于命令注入和系统横向渗透，RASP于Web漏洞，行为监测模型于0day攻击。</li>
<li>工程能力：代码能力，海量数据运营，规则的优化</li>
<li>运营能力主要体现在两个方面：<ul>
<li>风险闭环：“一个问题不能犯两次”</li>
<li>执行力</li>
</ul>
</li>
</ul>
</li>
<li>大规模生产网络的纵深防御架构<ul>
<li>互联网安全有几个比较核心需求：快速检测、有限影响、快速溯源、快速恢复。</li>
<li>互联网安全架构设计原则：<ul>
<li>纵深防御<ul>
<li>保护关键数据：层层设防，层层包围</li>
<li>多维防御：第一层、第二层、第三层、第四层</li>
<li>降维防御：例如在内核态检测用户态攻击，使用RASP在运行时而不是在cgi层面检测webshell，HIDS的攻击检测不在本机判定，而在云端计算，入侵者无感。</li>
<li>实时入侵检测</li>
<li>伸缩性、可水平扩展：非常重要</li>
<li>支持分布式IDC：互联网公司的生产网络一般多是IDC部署，对于海量IDC规模，需要支持去中心化、多级部署，解决一系列的失效、冗余和可用性问题。</li>
<li>支持自动化运维</li>
<li>低性能损耗：理论可行，实际情况可能业务无法接受</li>
<li>能旁路则不串联</li>
<li>业务无感知</li>
<li>去“信息孤岛”</li>
<li>TCO可控：自研的必然性</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>技术篇-基础安全措施<ul>
<li>安全域划分</li>
<li>系统安全加固：比如账户密码，大数据攻击（社工库）的都是弱密码</li>
<li>服务器4A：account,authentication,authorization,audit<ul>
<li>使用类似SSO的统一权限管理，目前有两种方式：一种是基于LDAP的方案；一种是基于堡垒机的方案。<ul>
<li>基于LDAP的方案：Linux平台-PAM(pluggable Authentication Modules) Windows平台-pGina，实现用户认证和访问管理，使得登录认证重定向到LDAP服务器做统一认证。</li>
<li>基于堡垒机的方案</li>
</ul>
</li>
</ul>
</li>
<li>一些tips<ul>
<li>大型互联网里，购买商业防火墙产品可能越来越少，大部分都会转换为使用Netfilter+高性能PC服务器。</li>
</ul>
</li>
<li>网络安全<ul>
<li>IDS 出口处部署NIDS，用于当有类似shellshock等漏洞公布时，可以在这里部署过滤规则，达到“虚拟补丁”的功能。</li>
<li>开源SNORT</li>
<li>入侵检测和入侵防护 P和D 在大型互联网公司的使用</li>
<li>DDoS分类<ul>
<li>网络层攻击<ul>
<li>Syn-flood 发送源地址的虚假SYN报文，导致目标主机无法完成3次握手</li>
<li>Ack-flood</li>
<li>UDP-flood</li>
</ul>
</li>
<li>应用层攻击<ul>
<li>CC(ChallengeCollapsar) 互联网架构追求扩展性本质上是为了提高并发能力,CC反其道而行之</li>
<li>DNS flood</li>
<li>慢速连接攻击</li>
<li>DOS攻击—服务器bug、漏洞、架构性缺陷</li>
<li>多层防御结构：第一层ISP近源清洗 第二层云清洗/CDN硬抗 第三层 DC级近目的清洗 第四层 OS/APP层抗CC</li>
</ul>
</li>
</ul>
</li>
<li>链路劫持<ul>
<li>DNS over TLS</li>
<li>HTTPS google推出的加密算法chacha20</li>
<li>AWS做的不错：SOC FISMA ITAR FIPS 140-2 MTCS HIPAA CSA-cloud Security Alliance MPAA</li>
</ul>
</li>
<li>应用防火墙WAF</li>
</ul>
</li>
<li>入侵感知体系<ul>
<li>主机入侵检测</li>
<li>检测webshell</li>
<li>RASP</li>
<li>数据库审计</li>
<li>入侵检测数据分析平台</li>
<li>入侵检测数据模型</li>
<li>数据链生态-僵尸网络</li>
<li>安全运营</li>
</ul>
</li>
<li>漏洞扫描</li>
<li>移动应用安全<ul>
<li>漏洞扫描、入侵感知和应急响应是技术维度日常工作中最重要的3部分</li>
<li>互联网的安全体系：基本上以运维安全、应用安全、业务安全三管齐下。</li>
<li>代码加固：IOS-Clang Static Analyzer Android-Findbugs</li>
<li>应用加固</li>
<li>移动认证</li>
</ul>
</li>
<li>代码审计<ul>
<li>自动化审计产品 《Data Flow Analysis in Software Reliability》数据流分析、状态机系统、边界检测、数据类型验证、控制流分析</li>
<li>代码审计工具：Coverity 支持C C++ Java 发现的问题：resource leaks 。。。</li>
</ul>
</li>
<li>办公网络安全<ul>
<li>研发管理：两台PC，一台不能联网，vlan分隔</li>
<li>源代码管理：github同步时泄漏密钥</li>
<li>远程访问：VPN最大的问题是暴力破解，双因素认证，RSA令牌</li>
<li>虚拟化桌面：Citrix</li>
<li>2015年年中，Google发布beyondCorp项目，宣称办公网络取消内网。其基本假设：内部网络实际上跟互联网一样危险。</li>
</ul>
</li>
<li>安全管理体系</li>
<li>隐私保护<ul>
<li>密钥管理基础设施KMI通常分两部分：<ul>
<li>密钥的存储</li>
<li>对密钥本身的访问授权管理</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>实践篇<ul>
<li>业务安全与风控</li>
<li>大规模纵深防御体系设计与实现</li>
<li>分阶段的安全体系建设</li>
</ul>
</li>
</ul>
</li>
<li>一些标准<ul>
<li>BS25999（BCM的一个标准）</li>
<li>ISO27001</li>
<li>BS7799</li>
</ul>
</li>
<li>其他参考文献</li>
</ul>
<ol>
<li><p>信息安全行业从业指南2.0 by ayaz3ro <a href="https://www.ifshow.com/information-security-industry-practitioners-guide-v2/" target="_blank" rel="noopener">https://www.ifshow.com/information-security-industry-practitioners-guide-v2/</a> </p>
<ul>
<li><p>几个趋势<br>1.企业安全管理最终都会向互联网公司学习–未来大多数公司都会复制自己业务到互联网，也就是大多数企业都会拥有互联网的属性。从现在看，互联网公司的安全管理方法论是领先传统公司整整一个时代的，完全不在一个量级上。你还在做传统的安全吗？夸张一点说你就快不属于这个行业了</p>
<p>2.向云迁移–云是一种趋势，虽然我不认为短期内马上会有非常多的公司将自己的业务迁移到公有云上，或者从头打造私有云。但是云计算折射出的IT管理方式，技术架构却会越来越成为安全管理的风向标，例如分布式IDC管理，虚拟化，SDN，海量运维生态，业务伸缩，大数据，高度自动化，敏捷发布……等很多带着时代标签的东西，安全管理体系的设计和产品化落地需要越来越多的围绕这些特性标签展开工作，如果你没有这方面的经验，也会逐渐out</p>
<p>3.倾向于以技术和产品（工具自动化）解决问题，而不再是以前宣扬的七分管理三分技术。看近些年的IT技术发展，本质上由Google、Facebook为代表的这些互联网公司带动，除了技术架构，像运维管理、研发生命周期管理、安全管理都在成为其他公司的教科书，安全的最高境界是让你身处于保护之中而不感觉那些繁琐措施和流程的存在，以技术、自动化、机器学习、人工智能为导向解决问题的价值观已超越流程制度的落后方式，也是过去那些理论标准越来越显得发虚的原因。</p>
</li>
<li>从这些趋势看，如果你是体系架构型，技术复合型（俗称全栈工程师），特定技术方向专攻型以后会受市场青睐，而“务虚型“的市场价值可能不太乐观。</li>
<li>过分迷恋于技巧对长足的发展没有好处。</li>
<li>价值一方面跟人才市场的供求关系有关，一方面也跟学习成本高低、获取技能的难易度有关。</li>
<li>第一代安全从业者的技能基本以OS和网络安全为主，1.5到第二代以广义的web service等应用安全为主，如果一定要说第三代，移动安全可能还算是当下比较热门，关注者比较多，相对前沿的领域，而从VC的角度看移动互联网可能都不再是热点，早已开始布局更下一代的东西了，也许是类似于人工智能这样的领域。</li>
<li>对个人来说一方面你到底需要多前沿的铺垫才能不out，另一方面则要考虑将自身定位收缩于哪些点才可能挖到最深，视野一定是尽可能的宽泛，是一个“放”字，但落到实践一定是个“收”字，以如今的技术复杂度你不可能样样都精通，只能挑几个。</li>
<li>关于创业，如果你原先是做安全产品研发，能带一支完整的团队出来，做的产品属于下一代类型或者干脆就是市场空白，不妨尝试一下，其他的类型我认为创业的成功率应该比较低。</li>
</ul>
</li>
</ol>
<h2 id="北京大学公开课《区块链技术与应用》笔记_（笔记阅读指数：）2020年2月7日">北京大学公开课《区块链技术与应用》笔记 （笔记阅读指数：）2020年2月7日</h2><ul>
<li>讲师：肖臻 </li>
<li>北大第一次区块链的公开课 我的笔记基本上是流水账，只是作为自己的备用参考，不值得阅读，后续有总结</li>
</ul>
<h3 id="BTC-密码学原理">BTC-密码学原理</h3><ol>
<li><p>Cryptographic hash function </p>
<ul>
<li>Collision resistance <ul>
<li>Hash函数的输入空间无限大，输出空间有限，客观存在hash碰撞</li>
<li>没有高效的找到hash碰撞的方法</li>
<li>Collision resistence 的作用：保证数据不被篡改，因为数据一篡改，hash值就变化了。</li>
<li>理论上，无法证明任何一个hash函数是Collision Resistence，只能从实践上说明</li>
<li>但有些hash函数之前是collision resistance，后来证明不是。一个著名的例子：MD5，已经找到可以hash碰撞的方法。</li>
</ul>
</li>
<li>hiding（单向函数）<ul>
<li>输入空间足够大，分布比较均匀</li>
<li>当输入空间不是足够大时，实际操作过程中：可以加一个随机数保证足够随机：H(X||nonce)</li>
</ul>
</li>
<li>collision resistance和hiding这两个性质，形成了一个digital commitment<ul>
<li>digital equipment of a sealed envelope</li>
</ul>
</li>
<li>puzzle friendly（输入的X（X只能一个一个试）对应的预测hash值。）<ul>
<li>difficult to solve, but easy to verify</li>
</ul>
</li>
<li>SHA-256:Secure Hash Algorithm</li>
</ul>
</li>
<li><p>区块链开户：创建一个公私钥对(public key,private key) 来源于非对称加密算法(asymmetric encryption algorithm)</p>
<ul>
<li>aysmmetric encryption algorithm 解决了密钥分发的问题：用公钥加密，用私钥解密</li>
<li>公钥—银行账户 私钥—-账户密码</li>
<li>用私钥签名，其他人用公钥验证。</li>
<li>一个可能的攻击方法：不停的产生公私钥对，和别人的公钥碰撞，如果相同，就可以用私钥将对方的账户偷窃。但这种攻击方法其实不可行，概率极小（比地球爆炸的概率还小）。</li>
<li>但前提是一个好的随机源：a good source of randomness。（公私钥的随机源，包括签名时也要有好的随机源）</li>
<li>区块链中，一般先hash，再签名</li>
</ul>
</li>
<li><p>BTC中的数据结构</p>
<ul>
<li>数据结构1 <ul>
<li>用hash指针（hash pointer）代替了普通指针</li>
<li>Block chain is a linked list using hash pointers.</li>
<li>区块链：genesis block &lt;—- H()  &lt;—- H()  &lt;—- H()  &lt;—- H()  &lt;—- most recent block</li>
<li>普通链表：可以改变其中一个元素，不改变其他元素。但区块链：改变一个元素，后面的其他元素都会被改变。 只要最后一个hash值，就可以验证前面的区块。</li>
<li>tamper-evident log</li>
</ul>
</li>
<li>数据结构2 Merkle Tree<ul>
<li>Merkle Tree 和 Binary Tree 的区别： hash指针代替了普通指针</li>
<li>Merkle Tree的数据结构：二叉树</li>
<li>block header + block body （轻节点：比如手机上的手机钱包应用只存储 block header；全节点：包括block header + block body ）</li>
<li>如何向轻节点证明一笔交易？用到 Merkle proof ：找到交易所在的位置，往上找到根节点（root hash），这个就是Merkle proof，向全节点请求一些hash值。<br>轻节点中只有root hash值，根节点hash值验证通过，则说明这个交易没有被修改。</li>
<li>这个证明也叫做Proof of membership 或者 Proof of inclusion，复杂度O(log(n))。证明这个交易不存在呢？即Proof of non-membership，一种方法是把所有的树结构发送给轻节点，判断正确后，检查这个节点不在叶节点中，复杂度为O(n),其他没有更好的办法，但是如果按照交易内容的hash值排序，如果要找的交易做hash，找到处于两者hash之间的两个Markle Tree，验证通过即可证明这个交易不存在，复杂度O(log(n))。这个方法的代价是排序：称为Sorted Merkle Tree。但比特币中没有使用Sorted Merkle Tree，因为比特币中无需证明交易不存在。</li>
</ul>
</li>
<li>注意：有环的链表都不能使用hash指针，因为会产生循环依赖。</li>
</ul>
</li>
<li><p>BTC协议</p>
<ul>
<li>double spending attack：花两次攻击（双花攻击）：因此要向央行验证这个数字货币是否使用过（可行，但这个事中心化方案）。</li>
<li>比特币要解决的问题：数字货币的发行（挖矿决定的）；数字货币的有效性。</li>
<li>数字货币的有效性：有签名+说明币来源（为了证明货币的合法性）</li>
<li>一个转账交易：A—-&gt;B 必须有B的公钥（账号），也必须要知道A的公钥（所有的节点都要知道A的公钥，用于验证）。那么如何知道A的公钥？</li>
<li>Block Header（version；hash of previous block header;Merkle root hash;target;nonce;）+block body(transaction list)</li>
<li>full node:全节点，保存区块链所有信息，也叫做fully validating node</li>
<li><p>light node:轻节点，只保存block header</p>
</li>
<li><p>如何保证账本的统一性：分布式共识 distributed consensus。</p>
<ul>
<li>一个方法是全局hash表 维护一个 distributed hash table</li>
<li>分布式系统的一些结论：有很多impossibility result，其中最著名的是FLP impossibility result。<ul>
<li>asynchronous系统：（异步系统：网络传输时延没有上限的系统）即使只有一个节点是faulty，也没法达成共识</li>
<li>CAP Theorem（CAP是分布式系统的三个性质：Consistency，Avalability，Partition tolerance）：只能满足两个</li>
<li>分布式共识的一个著名协议：Paxos，如果达成共识，一定是一致性的（consistency），但有可能Paxos一直不能达成共识</li>
</ul>
</li>
</ul>
</li>
<li><p>比特币中的共识协议：Consensus in BitCoin</p>
<ul>
<li>去中心化货币解决两个问题：1. 谁能合法发行货币 2. 交易的合法性<ol>
<li>铸币权<ul>
<li>唯一一个产生货币的交易：coinbase transaction 例子：50 BTC —-&gt; 25 BTC —-&gt; 12.5 BTC(21万个区块后，大约4年时间区块奖励减半。每隔10分钟产生一个区块，21万✖️10分钟=4年时间)   </li>
</ul>
</li>
<li>交易的合法性<ul>
<li>hyperledger fabric 联盟链协议：基于投票是可行的，因为大多数成员没有恶意的</li>
<li>比特币系统中不是这样的，因为产生公私钥对是不需要批准的。</li>
<li>sybil attack 女巫攻击：一个节点不断产生公私钥对，超过51%的数量，就能通过投票控制区块链。</li>
<li>比特币系统的解决方法：也是用投票的方法，但用的是计算力来投票。计算：穷尽4 bytes nonce：满足H(block header)&lt;= target，则获得了记账权。</li>
<li>forking attack 分叉攻击</li>
<li>longest valid chain:被选择的区块，丢弃的区块：orphan block</li>
<li>争夺记账权的好处：获得记账权的节点有一定权力：决定哪些交易可以被写到区块里。但这个不是主要动力，因为设计者希望合法交易都可以写到区块链中。区块奖励 block reward</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre><code><span class="bullet">* </span>共识的内容：指的是区块链中的交易内容
<span class="bullet">* </span>基于算力的投票：hash rate（计算nonce的速度）作为投票的权重。如何避免sybil attack：创建账户，并不能增加hash rate的能力。
<span class="bullet">* </span>争夺记账权的说法：挖矿 mining digital gold，争夺记账权的节点：矿工miner。
</code></pre><ol>
<li><p>BTC实现</p>
<ul>
<li>transaction-based ledger</li>
<li>维护一个数据结构：UTXO：Unspent Transaction Output。全节点在内存中维护UTXO的目的：检查double spending。</li>
<li>一个交易可以有多个输入（每个输入都要有签名），有多个输出，但要满足：total inputs = total outputs</li>
<li>比特币中的另一个激励机制：transaction fee，交易费。</li>
<li><p>account-based ledger</p>
</li>
<li><p>Bernoulli trial：a random experiment with binary outcome</p>
</li>
<li>一连串的Bernoulli trial构成了Bernoulli process：a sequence of independent Bernoulli trials。<ul>
<li>Bernoulli process的一个特征：无记忆性 memoryless，指的是做了多次实验，下一次成功的概率和之前的无关，仍然一致。</li>
</ul>
</li>
<li><p>Bernoulli process可以用poisson process近似。实验的次数很多，每次的实验成功的概率很小。我们关心的是：出块时间，理论推导出出块时间符合指数分布expontial distribution。<br>process free：指的是以前的工作并不影响后面找nounce的概率。如果process free不成立，算力强的矿工会产生不成比例的优势，是挖矿公平的保证。</p>
</li>
<li><p>比特币的数量每隔4年（每21万个区块）减半，产生一个几何级数 geometric series: 21万✖️50+21万✖️25+21万✖️12.5+…=21万✖️50✖️(1+1/2+1/4+…)=2100万</p>
</li>
<li><p>Bitcoin is secured by mining。挖矿没有实际意义，但能保证比特币的安全性。</p>
</li>
<li><p>比特币的安全性分析</p>
<ul>
<li>double spending attack：M-&gt;A这个交易先之行，后M-&gt;M’，然后将这个作为最长合法链。</li>
<li>forking attack</li>
<li>防范这种攻击的方法：多几次确认， confirmation： one confirmation，。。。，six confirmation。六个confirmation，平均一个块十分钟，这个就是一个小时</li>
<li>irrevocable ledger：凡是写入区块链的内容都永远改不了。</li>
<li>zero confirmation：</li>
<li>selfish mining：挖矿，挖到一个区块，不急着发布，藏着一条链，分叉攻击的手段，只有当：恶意节点和其他同伙的算力超过51%才有可能成功。<br>selfish mining的两个目的：1是获得常用（比如取消某一个交易）  2 是减少竞争（一次发布2个区块，别人挖到的块就失效了）。风险是有可能失败</li>
</ul>
</li>
</ul>
</li>
<li><p>BTC网络 The Bitcoin Network</p>
<h2 id="application_layer：_Bitcoin_Block_chain">application layer： Bitcoin Block chain </h2><p>network layer： p2p Overlay Network<br>（简单的p2p网络，没有所谓的超级节点super node，或者master node。<br> 有一个seed node，它会告诉你其他节点，tcp通信用于穿透防火墙</p>
<h2 id="当你退出时，直接退出，当其他节点没有收到你的信息时，就会删除你这个节点）"> 当你退出时，直接退出，当其他节点没有收到你的信息时，就会删除你这个节点）</h2><ul>
<li>比特币的设计原则是：简单，鲁棒。而不是高效。  simple,robust but not efficient<br>flooding 节点第一次收到洪流消息后，节点把这个传输给其他节点，同时记录下这个消息我已经收到过了，下次再收到这个消息，就不转发给其他邻居节点。</li>
<li>best effort：有的节点不转发一些合法交易，有的节点转发一些不合法交易</li>
</ul>
</li>
<li><p>BTC-挖矿难度</p>
<ul>
<li>H(block header)&lt;=target SHA-256 输入空间2^256</li>
<li>1_target： difficulty=1时的目标阈值 target</li>
<li>difficulty = (difficulty - 1_target)/target</li>
<li>产生区块的时间越短，就会产生分叉，分叉的后果：就是恶意节点集中算力增加自己的区块，导致攻击。<br>而以太坊的区块时间是15秒，产生一个新的共识协议：ghost协议：分叉的orphan block会得到一些奖励uncle reward。</li>
<li>出块时间无论多长，但都要保持稳定。</li>
<li><p>如何修改挖矿难度：</p>
<ul>
<li>每隔2016个区块就调整一次挖矿难度，大约是2个星期的时间。2016✖️10分钟/60/24=14天。</li>
<li>目标阈值(实际比特币代码中使用的是目标阈值)：target = target✖️actual time/expected time  expected time：2016✖️10分钟 actual time：time spent mining the last 2016 blocks（实际产生2016个区块的时间）注意：阈值一次调整最大不超过4倍，，最小是1/4，防止系统出现意外情况。</li>
<li>挖矿难度：next_difficulty = previous_difficulty✖️expected time(2 weeks)/actual time</li>
<li>问题：当恶意节点不调整这个target，通不过nBits的区块合法性检测。target 256 bytes ，nBits 4bytes</li>
<li>以太坊是可以自己修改自己产生的区块时间，比比特币复杂得多。</li>
</ul>
</li>
<li><p>比特币系统的总算力的变化情况</p>
</li>
</ul>
</li>
<li><p>BTC-挖矿</p>
<ul>
<li>全节点<ul>
<li>一直在线</li>
<li>在本地硬盘上维护完整的区块链信息</li>
<li>在内存中维护UTXO集合，以便快速检验交易的正确性</li>
<li>监听比特币网络上的交易信息，验证每个交易的合法性</li>
<li>决定哪些交易会被打包到区块里</li>
<li>监听别的矿工挖出来的区块，验证其合法性</li>
<li>挖矿<ul>
<li>决定沿着哪条链挖下去？（最长合法链）</li>
<li>当出现等长的分叉时，选择哪一个分叉？（最先听到的那个分叉）</li>
</ul>
</li>
</ul>
</li>
<li><p>轻节点</p>
<ul>
<li>不是一直在线</li>
<li>不用保存整个区块链，只要保存每个区块的块头（与都保存相比，差出1000倍）</li>
<li>不用保存全部交易，只保存与自己有关的交易</li>
<li>无法检验大多数交易的合法性，只能检验与自己相关的那些交易的合法性</li>
<li>无法检测网上发布的区块的正确性</li>
<li>可以验证挖矿的难度</li>
<li>只能检测哪个是最长链，不知道哪个是最长合法链</li>
</ul>
</li>
<li><p>比特币上的安全性（类似银行给拥有合法身份的人钱）</p>
<ul>
<li>密码学的保证：随机源足够随机</li>
<li><p>共识机制：只给合法身份的人</p>
</li>
<li><p>CPU—&gt;GPU(浮点运算是深度学习需要的)—&gt;ASIC：Application Sepcific Intergrated Circus（mining puzzle）一个芯片设计给一个加密货币</p>
</li>
<li><p>设计Alternative mining puzzle：抗ASIC resistance。</p>
</li>
<li><p>挖矿的趋势：大型矿池的出现。pool manager + miner + miner+ miner+ miner。</p>
<ul>
<li>pool manager：全节点的功能；miner：只计算hash值</li>
<li>解决收入不稳定的问题：因为挖矿太难了，所以降低挖矿难度即可：share = almost valid block。根据矿工提交的share数目，分配工作量</li>
<li>问题1:不可能偷区块奖励。因为除了nonce，还有其他域的值需要调整（coinbase中有收款人的地址=矿主的地址）。</li>
<li>问题2: 可能捣乱吗？挖到一个正确的区块，扔掉，谁也得不到了。分红别人挖到的块。</li>
<li>大型矿池的一个弊病：当有人控制了大型矿池，吸引一些不明真相的群众，这样就能发动51%的攻击：攻击包括分叉攻击；Boycott：发现包含某个交易后就分叉，如果拥有51%算力，就可以将分叉的区块链作为最长合法链，这样别的节点也不包含这些交易了，因为包含了就分叉。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol>
<li><p>BTC-比特币脚本</p>
<ul>
<li>只有堆栈，没有C语言那些全局变量，动态数组等。</li>
<li>P2PKH(Pay to Public Key Hash)最常用的</li>
<li>P2SH(Pay to script hash)最复杂的一种：其中一个应用场景是：对多重签名的支持</li>
<li>Proof of Burn：不管输入脚本是什么，输出到Return都会返回。两种应用场景：1.销毁比特币，可以得到一些小币种AltCoin(Alternative Coin)。2.digital commitment（专利内容做hash，证明当时已经知道这个知识了）<br>// 首先运行解锁脚本<br>0: [] // 初始状态：空堆栈<br>1: [签名] // PUSHDATA 入栈签名<br>2: [签名, 公钥] // PUSHDATA 入栈公钥<br> // 复制堆栈后运行上锁脚本<br>3: [签名, 公钥, 公钥] // DUP 复制栈顶公钥<br>4: [签名, 公钥, 公钥哈希] // HASH160 取出栈顶公钥，压入它的哈希<br>5: [签名, 公钥, 公钥哈希, 目标公钥哈希] // PUSHDATA 入栈目标公钥哈希<br>6: [签名, 公钥] // EQUALVERIFY 取出栈顶两个哈希，确认它们等值，否则验证失败<br>7: [TRUE] // CHECKSIG 取出栈顶的公钥和签名，验证交易，入栈检查结果<br> // 栈顶为真值则验证成功</li>
</ul>
<p>2 PUSHDATA(公钥A) PUSHDATA(公钥B) PUSHDATA(公钥C) 3 CHECKMULTISIG<br>   // 首先运行解锁脚本<br>0: [] // 初始状态：空堆栈<br>1: [0] // 0 被压入栈顶<br>2: [0, 签名D] // 0Z PUSHDATA 入栈第一个签名<br>3: [0, 签名D, 签名E] // PUSHDATA 入栈第二个签名<br>4: [0, 签名D, 签名E, 脚本] // PUSHDATA 入栈完整脚本<br>   // 复制堆栈后运行上锁脚本<br>5: [0, 签名D, 签名E, 脚本哈希] // HASH160 取出栈顶脚本，压入它的哈希<br>6: [0, 签名D, 签名E, 脚本哈希, 目标脚本哈希] // PUSHDATA 入栈目标脚本哈希<br>7: [0, 签名D, 签名E, TRUE] // EQUAL 取出栈顶两个哈希，判断是否相等，压入检测结果<br>   // 取出栈顶结果，如果非真，则验证失败，否则运行原始脚本<br>8: [0, 签名D, 签名E] // 准备运行原始脚本<br>9: [0, 签名D, 签名E, 2] // 2 被压入栈顶<br>10: [0, 签名D, 签名E, 2, 公钥A] // PUSHDATA 入栈第一个公钥<br>11: [0, 签名D, 签名E, 2, 公钥A, 公钥B] // PUSHDATA 入栈第二个公钥<br>12: [0, 签名D, 签名E, 2, 公钥A, 公钥B, 公钥C] // PUSHDATA 入栈第三个公钥<br>13: [0, 签名D, 签名E, 2, 公钥A, 公钥B, 公钥C, 3] // 3 被压入栈顶<br>14: [0, 签名D, 签名E, 2, 公钥A, 公钥B, 公钥C] // CHECKMULTISIG 先取出公钥数N(3)<br>15: [0, 签名D, 签名E, 2] // 接着取出N(3)个公钥<br>16: [0, 签名D, 签名E] // 再取出签名数M(2)<br>17: [TRUE] // 接着取出M(2)个签名和数字0，根据交易验证签名，压入检查结果</p>
<pre><code><span class="comment">// 栈顶为真则验证成功</span>
</code></pre></li>
</ol>
</li>
</ol>
<ol>
<li><p>BTC-分叉</p>
<ul>
<li>fork的几种情况</li>
<li>同时挖到矿，临时分叉 state fork</li>
<li>分叉攻击 forking attack（deliberate fork）</li>
<li>修改协议，有些节点不修改 protocal fork：根据协议修改的：<ul>
<li>hard fork ：例子：block size limit 1M字节 1个交易250字节，1000000/250=4000个交易/每个交易 4000/60/10=7 tx/sec。只要旧节点不更新软件，这个分叉就不会消失，所以叫硬分叉。实际的例子：以太坊：ETH 分叉为ETH 和 ETC ，为了防止回放，加上了一个chain ID</li>
<li>soft fork：新的协议下，有些合法的交易变得不合法了。旧节点不更新，白挖矿了，但不会产生永久的分叉。<br>实际例子：当给域赋予一些新的意义时，coinbase（铸币域）前8字节可以作为extra nonce ，调整挖矿难度：4字节+8字节=2^96。<br>比特币历史上的一个著名例子：P2SH：Pay to Script Hash 。旧节点只验证 redeem script是否正确，新节点才验证第二阶段的验证。</li>
</ul>
</li>
<li>小结：<ul>
<li>soft fork：当超过算力51%的节点都更新了软件，就不会产生硬分叉。</li>
<li>hard fork：必须所有的节点更新软件，才不会产生永久性的分叉。</li>
</ul>
</li>
</ul>
</li>
<li><p>BTC-问答</p>
<ul>
<li>转账交易不需要对方账户在线</li>
<li>如果你账户的私钥丢失了，怎么办？私钥丢失了，账户的钱就取不出来了。著名例子：Mt.Gox，翻译为门头沟</li>
<li>如果私钥泄漏了怎么办？尽快转账到自己的另外一个账户。</li>
<li>如果转账的时候，写错了地址怎么办？没有办法，没法取消已经发布的交易</li>
<li>如果转账的地址不存在，这是不友好的，因为需要一直存在UTXO中</li>
<li>矿工偷nonce问题：别的矿工发布的nonce，其他矿工偷过来作为自己找到的，不能。因为有coinbase域中有矿工的收款地址，Merkle Tree就通不过。</li>
<li>交易费不用知道矿工：因为total inputs&gt;total outputs，差值就是交易费。</li>
</ul>
</li>
<li><p>BTC-匿名性 anonymity</p>
<ul>
<li>pseudonymity </li>
<li>多个公私钥对可能会关联在一起，分析比特币钱包的交易生成方式即可搞清楚关联方式</li>
<li>资金转入转出都会引起注意，这是和实体世界相关联。</li>
<li>(研究) 信用卡数据公开，但隐私保护去除了姓名和性别，卡号等，但通过行为，比如什么时间买了什么东西，很快就可以将这个人和信用卡关联起来。比特币的所有交易都是公开的。</li>
<li>silk road（ebay for illegal drugs）比特币支付+TOR 洋葱路由 （网络层）。这个老板2，3年后被抓（几万个比特币都没有使用，旧金山被抓，可能是由于一台电脑上登陆了实际账户和虚拟账户）。</li>
<li>如何提高匿名性？<br>application layer（应用层保证匿名性：coin mixing 没有信用度很高的coin mixing服务。在线钱包：将大家的比特币混合）</li>
</ul>
<hr>
<p>network layer（首先，保证网络层的匿名性：学术界有很多解决方案，一般是多路径转发的方法，TOR）</p>
<ul>
<li>零知识证明：是指一方（证明者）向另一方（验证者）证明一个陈述是正确的，而无需透露除该陈述是正确外的任何信息。</li>
<li>零知识证明的数学基础是同态隐藏。</li>
<li>不碰撞：x,y不同，E(x)和E(y)不同（逆否命题一定成立：如果E(x)=E(y)，那么x=y）</li>
<li>不可逆：给定E(x)的值，无法推出x的值 （类似hash函数的hiding property）</li>
<li>同态运算：同态加法+同态乘法+扩展到多项式</li>
<li>盲签原理：在不知道内容的情况进行签名</li>
<li>零币和零钞：专门为匿名性设计的加密货币。协议层就融合了匿名化处理。</li>
<li>零币：类似于混币处理。</li>
<li>零钞：zk-SNARKs。但都没有解决和实体交互的匿名性问题。</li>
</ul>
</li>
</ol>
<ol>
<li><p>BTC-思考</p>
<ol>
<li>hash指针如何传播？实际使用时，其实没有指针，只有hash。那如何找到区块呢？区块链是存在key value的数据库level DB中。</li>
<li>区块恋：私钥分成两块，一人保存一块。问题是：降低了安全性，2^256 —-&gt; 2^128；永久存储在UTXO中。可以用多重签名的方法-MULTISIG。</li>
<li>分布式共识：分布式系统中，理论上证明达成共识不可能的。为什么比特币能够绕过分布式共识的那些不可能结论？实际上的模型修改下，就不是理论上的模型了。比特币就是这样做的，不要被学术界的思维限制，不要被程序员的思维限制。</li>
<li>比特币的稀缺性：早期挖矿的收益高。货币总量固定不适合做货币，一个好的货币需要有通货膨胀功能。</li>
<li>量子计算：首先量子计算离实际使用还很远。而且这个对传统金融业的冲击更大，还有量子加密算法。地址（公钥—hash再转换）—-&gt;生成私钥，量子计算能从公钥算出来私钥。<br>最好的做法：进行一次交易后，将地址中的钱全部转走，或者转给自己另一个账户，好处有二：增强了安全性；隐私保护。<br>公钥最好也不要随便泄漏。</li>
</ol>
</li>
<li><p>以太坊概述</p>
<ul>
<li>比特币：区块链1.0；以太坊：区块链2.0</li>
<li>以太坊的改进：</li>
<li>出块时间：10分钟—15秒，并设计了对应的共识协议GHOST协议</li>
<li>mining puzzle：导致挖矿设备的专业化（ASIC芯片的挖矿机，与去中心化的理念不符）。ASIC resistance。</li>
<li>用权益证明代替工作量证明。proof of work —-&gt; proof of stake。类似股份，投票</li>
<li>增加了智能合约的支持：smart contract。<br>去中心化的货币——&gt;去中心化的合约，合同。<br>BitCoin：decentralized currency。BTC 最小单位：Satoshi<br>Ethereum：decentralized contract。ETH 最小单位：Wei</li>
<li>去中心化的合同有什么好处？去中心化的货币有什么好处？跨国转账。<br>技术上保证从一开始合同就不能违约。区块链的一个特点就是不可篡改。</li>
</ul>
</li>
<li><p>以太坊的账户模式</p>
<ul>
<li>比特币的模型：基于交易；以太坊的模型：基于账户的模型account-based ledger。这个好处：double spending ，天然防御作用。弱点：replay attack</li>
<li>普通外部账户（公私钥）：externally owned account：balance（余额） nonce（计数器，使用账户的次数）</li>
<li>smart contract account（智能合约账户）：不能主动发起交易，发起交易需要普通账户发起。balance nonce code storage </li>
<li>为什么要创建以太坊？Vitalik创始人。比特币是基于交易的，隐私性比较好。智能合约：用稳定的身份，基于account的模型，保持稳定。</li>
</ul>
</li>
<li><p>以太坊的数据结构：状态树</p>
<ul>
<li>账户地址到账户状态的映射：地址160bits，一般表示为40个16进制的数；状态：state。</li>
<li><p>hash表（键值对）？如果证明自己的余额，Merkle Tree。比特币基于交易的Merkle Tree，一个区块上限4000个，一般是几百个到几千个。而基于账户的以太坊，每创建一个账户，就会重新构建一个Merkle Tree，数量级大量增加。<br>只维护一个Merkle Tree，Merkle Tree没有好的查找插入方法，Merkle Tree需要排序吗？不排序查找速度很慢，不排序导致状态不一致，各个全节点算出来的Merkle hash不一样，而比特币中是发布区块的节点唯一确定的。</p>
</li>
<li><p>trie（来自retrieval信息检索）字典前缀树： 字符串。<br>branding factor </p>
</li>
<li>特点1: 0-f 加一个结束标志符。地址为40个16进制数</li>
<li>特点2：key值越长，查找的复杂度越大，</li>
<li>特点3：hash表有可能有碰撞，trie不会出现碰撞，只要地址不一样，一定不一样</li>
<li>特地4：不同的节点构造出来的trie结构是一样的。</li>
<li>特点5：更新的局部性很好。因为只要更改局部的即可。</li>
<li>Patricia Tree/Trie 经过压缩的trie 路径压缩：好处是Tree的高度降低，内存访问速度增加。</li>
<li>地址160bits，地址分布非常稀疏，目的是为了防止碰撞</li>
<li>MPT Merkle Patricia tree </li>
<li>和PT的区别在于：加入了hash指针</li>
<li>Modified MPT：extension node  branch node leaf node</li>
<li>保存历史状态：因为智能合约的以太坊是图灵完备的，因此推算前一个状态是不可能的，无法形成回滚 roll back</li>
<li>以太坊中有三个树：状态树（key values）=（地址，），交易树，收据树</li>
<li>状态树：key-地址，value-序列化：RLP：Recursive Length Prefix （极简主义，序列化的方法） nested array of bytes</li>
</ul>
</li>
<li><p>以太坊：交易树 收据树</p>
<ul>
<li>bloom filter数据结构：支持高效查找：某个指定元素是否在这个集合中。（元素做hash，映射到一个向量中） </li>
<li>轻节点：通过块头的Merkle hash过滤掉大多数，再到少部分中去找。</li>
<li>以太坊的运行过程可以看作是一个交易驱动的状态机。状态：所有账户的状态，交易：每次发布区块时包含的交易。</li>
<li>比特币也可以看作一个交易驱动的状态机。状态：UTXO</li>
</ul>
</li>
<li><p>以太坊：共识机制 GHOST协议</p>
<ul>
<li>motivation：以太坊的分叉很多（相比于比特币），那么矿池获得最长合法链的概率不成比例的增加，centralization bias。</li>
<li>GHOST协议：没有成为最长合法链的区块orphan block或者stale block，也有区块奖励。以太坊中称为uncle block。</li>
<li>Uncle block可以得到7/8✖️3ETH。包括Uncle block的区块链可以得到1/32✖️3+3，而且最多可以包括2个Uncle block。</li>
<li>合法的Uncle block 最多7代，7/8，6/8，5/8，4/8，3/8，2/8。Uncle reward</li>
<li>把Uncle block添加进来，要不要执行交易？不执行，可能和主链上的交易冲突。</li>
<li>分叉后第二，三，个区块怎么办？以太坊规定：只要分叉第一个区块才能得到奖励。因为forking attack的代价便宜很多，因为攻击成了，就回滚达到攻击目的，如果不成就被招安得到奖励。</li>
</ul>
</li>
<li><p>ETH-挖矿算法（bug bounty）</p>
<ul>
<li>Block chain is secured by mining</li>
<li>one cpu，one vote—-中本聪</li>
<li>因此，后面的挖矿算法要保证 ASIC resistance，增加对puzzle求解对内存的需求 memory hard mining puzzle，怎么设计呢？著名的例子 LiteCoin：用的是scrypt，128K内存</li>
<li>好处：增加了对内存的访问需求，memory-hard</li>
<li>坏处：对轻节点也是memory-hard。</li>
<li>而puzzle设计的原则：difficult to solve，but easy to verify。</li>
<li>LiteCoin和比特币的差别：1 puzzle难题不同 2 出快时间2分半，是比特币的四倍。除此之外，基本一样。</li>
<li>ethash（以太坊使用的puzzle）：</li>
<li>两个数据集 16M cache 1G dataset，DAG（定期增长）</li>
<li>16M cache：seed 经过变换产生一个伪随机数，再hash产生下一个伪随机数。。。</li>
<li>1G dataset：伪随机位置寻找256次，找到一个数放到第一个位置，</li>
<li><p>block header nonce 一次读取128个位置，计算得到一个位置，包括相邻元素也读取出来，循环64次，每次读取2个元素，因此是128个元素</p>
</li>
<li><p>伪代码分析：每隔30000个块会重新生成seed（对原来的seed做hash值），并且利用新的seed生成新的cache。cache的初始大小为16M，每隔30000个块重新生成时增大初始大小的1/128—-128K。</p>
</li>
<li><p>目前以太坊挖矿基本上是GPU，起到了ASIC resistance的作用。</p>
</li>
</ul>
</li>
<li><p>ETH-难度调整</p>
<ul>
<li>黄皮书和代码都有不一致的地方，这里以代码为依据</li>
<li>D(H)=max(D0,P(H)Hd+xs2)+epston P(H)Hd：父区块 D0=131072</li>
<li>难度炸弹：PoW向PoS转换。工作量证明向权益证明转换。</li>
<li><p>问题是PoS有很多问题不好解决，无法上线，而难度越大，出块时间越长，15秒—16秒—-17秒，因此，向后回调了300万个区块。</p>
</li>
<li><p>以太坊的四个阶段：</p>
</li>
<li>Frontier</li>
<li>Homestead</li>
<li>Metropolis <ul>
<li>Byzantium(难度回调在此阶段中，在EIP（Ethereum Improvement Proposal）中决定，同时把Block Reward 从5个ETH将为3个ETH) BIP（BitCoin Improvement Proposal）</li>
<li>Constantinople</li>
</ul>
</li>
</ul>
</li>
<li><p>ETH-Proof of Stake</p>
<ul>
<li>比特币一个诟病：浪费电 KHW THW（Tero watt hours）</li>
<li>比特币：每年能耗70THW，每个交易的能耗是1014KWH。比特币每年挖矿的总收入60亿美元</li>
<li><p>以太坊：每年能耗20THW，每个交易的能耗是67KWH。因为出块时间短，虽然还有智能合约。每年挖矿的总收入50亿美元，费用是24亿美元</p>
</li>
<li><p>PoS：proof of stake</p>
</li>
<li>挖矿-设备多-算力大-挖矿多-收益多：所以挖矿取决于钱，拼钱</li>
<li>virtual mining，相比较proof of work，好处有<ul>
<li>能耗更少，环境污染小，温室气体排放少</li>
<li>不是加密货币的闭环，因为矿机是用加密货币之外的法币购买的。发动攻击，所需的资源可以从外部获得，比如购买矿机。比如AltCoin，对这种小币攻击很容易，而且致命性的，Infanticide。</li>
<li>有的采用混合模型：也要挖矿，挖矿的难度和你持有币多少相关，持有币越多，挖矿难度越小。这个设计也有问题：持有币最多的人，挖矿最容易。有的币会锁定一段时间，Proof of Deposit</li>
<li>基于权益证明有很多挑战：<ul>
<li>一 nothing at stake：上面链可以挖，下面链也可以挖矿</li>
</ul>
</li>
</ul>
</li>
<li>以太坊中的权益证明协议是：Casper the friendly Finality Gadget（FFG）：引入一个概念Validator，推动链达成共识，形成共识<ul>
<li>two-phase commit：Prepare Message 2/3 Commit Message 2/3 </li>
<li>以太坊中权益证明：50个区块=1个epoch，连续两个epoch投票都是2/3，才算有效</li>
<li>验证者，验证会得到奖励，跟挖矿得到奖励一样。相应的，不作为的验证者，没收部分保证金，乱作为的验证，没收全部保证金，销毁。</li>
</ul>
</li>
<li>Finality是否可能被推翻？权益证明不成熟，工作量证明经历了历史的考验</li>
<li>EOS 柚子：采用的就是权益证明，DPOS共识协议：Delegated Proof of Stake：选举出一些超级节点，再投票。。。</li>
<li>工作量证明的一些好处：提供了一种将电能转换为钱的方式。电不好存储和传输，偏远地区清洁能源的电，不好传输到电主网中，因此可以用挖矿将电能转换为比特币，存储和传输就容易了。</li>
</ul>
</li>
<li><p>ETH-智能合约（以太坊的精髓）</p>
<ul>
<li>什么是智能合约？是运行在区块链上的一段代码，代码的逻辑定义了合约的内容。</li>
<li>智能合约的账户保存了合约当前的运行状态：</li>
<li>balance 当前余额</li>
<li>nonce 交易次数</li>
<li>code 合约代码</li>
<li>storage 存储，数据结构是一棵MPT</li>
<li>Solidity 是常用的语言，类似JavaScript</li>
<li>强类型语言 address 特殊类型</li>
<li>建议：construct 构造函数</li>
<li>外部账户可以调用智能合约</li>
<li>一个合约调用另一个合约的函数？</li>
<li>直接调用</li>
<li>代理调用 delegatecall()</li>
<li>fallback()函数</li>
<li>不调用任何函数，就调用fallback函数，若没有这个函数，则抛出异常</li>
<li>智能合约的创建和运行</li>
<li>运行在EVM(Ethereum Virtual Machine)， World Wide Computer 256位。比如：增加JVM，加强一致性。</li>
<li>智能合约是个Turning-complete Programming Model<ul>
<li>出现死循环怎么办？没有办法，这个是Halting Problem，不是NPC问题（可以解的），复杂度是指数级。</li>
</ul>
</li>
<li>汽油费gas fee，由发起交易的人支付</li>
<li>EVM中不同指令消耗的汽油费是不一样的（比如hash运算gas fee高）</li>
<li>错误处理</li>
<li>会产生回滚，回到交易执行之前的状态</li>
<li>assert语句：判断内部条件</li>
<li>require语句：判断外部条件</li>
<li>revert语句：无条件抛出异常，回滚状态变动</li>
<li>嵌套调用</li>
<li>直接调用：会产生连锁回滚</li>
<li>call调用：就不会产生连锁回滚</li>
<li>全节点维护三个数据结构：状态树，交易树，收据树。状态的修改都是在修改本地的数据结构。</li>
<li>先执行再挖矿！执行完交易后，更新三个数据结构，更新3个roothash，再尝试nonce，挖矿。</li>
<li>gas fee是给那些发布智能合约的矿工的一种补偿，但如果没发布的矿工，什么补偿都没有，就是“陪太子读书”。</li>
<li>有没有一些区块，不独立验证交易的合法性。这样会导致区块链的安全问题。因为区块链的安全性取决于每个全节点独立验证交易的安全性。而这些全节点不可能不验证交易的合法性，因为根hash值不对了，就没法发布区块了。（先执行交易，再更新三棵树）</li>
<li>问题：智能合约的错误，要不要也发布到区块链中去？要！错误的交易也要发布到区块链中去，形成共识，才能获得汽油费。</li>
<li>问题：智能合约支持多核并行处理吗？可以的。solidity不支持多线程。</li>
<li>多线程：寄存器是自己的，大部分是共享的，多线程会导致访问内存的不确定，这个和以太坊是交易驱动的状态机相违背，因为所有全节点都要验证，因此状态的转换是确定的。</li>
<li>三种函数 发起转账</li>
<li>transfer 会发生连锁回滚</li>
<li>send 返回false，不会发生连锁回滚</li>
<li>call.value(uint256 amount) 返回false，不会发生连锁回滚。区别：把剩下的所有汽油都发过去</li>
<li>auctionE nd() bid() 函数。</li>
<li>重入攻击（Re-entrancy Attack）：你调用的合约有可能再调用你这个合约，所以先清除状态，再执行操作</li>
</ul>
</li>
<li><p>ETH-TheDAO</p>
<ul>
<li>DAO Decentralized Autonomous Organization 去中心化的自治组织</li>
<li>2016年5月出现：The DAO。众筹，民主投票决定。</li>
<li>DAC Decentralized Autonomous Corporation</li>
<li>取回资金：splitDAO childDAO 唯一路径：只能拆分成childDAO，取出来。</li>
<li>拆分的理念：符合民主的理念，就是不是少数服从多数，少数也可以拆分出来。</li>
<li>问题出现在splitDAO的代码实现上：先把余额清零，再转账。（重入攻击）子基金有28天的锁定期。</li>
<li>出现两派：1.too big to fail 补救 2. code is law 不补就</li>
<li>软件升级：软分叉。增加了一个规则：DAO相关的交易都是非法的交易，但这个有一个bug：非代码bug，而是功能bug，没有收取汽油费，因此导致攻击（不消耗汽油费，恶意节点不断产生这种交易，新升级的节点受不了都回到旧版本） </li>
<li>通过软件升级的方法，把DAO智能合约上的所有资金强行转到新的智能合约上，这个新的智能合约只有一个功能：退钱，D币转换为以太币。硬分叉：因为旧矿工认为这个交易是非法交易。最后通过投票支持了硬分叉。</li>
<li>硬分叉：新链是 ETH 旧链 ETC Ethereum Classic 上交易所。一直存活在现在。两条链同时存在有一个问题：重放攻击，新链上的交易可以放到旧链上，反之亦然。因此增加了ChainID。</li>
<li>问题：为什么不能针对黑客账户进行退？而是都按照所有账户的方式处理。因为这个bug不可以修改，智能合约只能作废。</li>
</ul>
</li>
<li><p>ETH-反思</p>
<ul>
<li>智能合约其实就是自动执行的合约，Is smart contract really smart? </li>
<li>反思1 Smart contract is anything but smart.</li>
<li>反思2 Irrevocability is a double ledged sword</li>
<li>反思3 nothing is irrevocable（18修正案—21修正案 大街上饮酒，车里的人都不能喝酒 是违法的 open container laws）</li>
<li>反思4 Is solidity the right programming language？ 语言设计：solidity语言，调用时，违法直觉，是调用fallback函数。有人建议：使用函数式语言。康奈尔大学 函数式编程语言 Ocaml，做的工作是：formal verification。形式化证明这个代码只能实现这个功能。</li>
<li>智能合约的语言具有什么样的表达能力？图灵完备，还是中间语言。</li>
<li>有可能的解决方法：模板</li>
<li>开源的好处：大家监督，增加公信力。不容易产生漏洞。但为什么这么多人看着，还出现漏洞，有人称为Many eyeball fallacy。所以，开源的不一定安全。</li>
<li>What does decentralization mean？最后是投票，也有矿工留在旧链。</li>
<li>分叉是去中心化的体现。</li>
<li>decentralized ！= distributed</li>
<li>状态机 state machine 是为了容错！最早的应用场景是mission critical application；airtraffic control；stock exchange；space shuttle。以前这种情况下机器都很少，个位数。</li>
<li>智能合约是用来编写控制逻辑的。</li>
</ul>
</li>
<li><p>ETH-美链 Beauty chain</p>
<ul>
<li>在美莲上做ICO。 Initial Coin Offering</li>
<li>没有自己的区块链，代币的发行，转账都是通过调用智能合约中的函数来完成。</li>
<li>ERC 20是以太坊上发行代币的一个标准，规范了所有发行代币的合约应该实现的功能和遵循的接口 ERC Ethereum Request for Comments</li>
<li><p>代码分析： uint256 amount = uint256(cnt) * _value. 溢出，amount 很小，但转账时依然很大，因此导致系统中凭空产生了很多的代币。</p>
</li>
<li><p>反思1:应该检查溢出 比如：math库中，都是 a=b*c assert(a/c == b),加法减法都调用的是库，而乘法没有使用库。</p>
</li>
</ul>
</li>
<li><p>总结（应用上）</p>
<ul>
<li>退款不是取消之前的交易，而是发起一个新的交易。</li>
<li>法律保护？没有司法保护，美国信用卡在2个月内申诉，最多50美元的损失。比特币没有这个保护。</li>
<li>比特币本来就没有必要和已有支付方式的竞争</li>
<li>加密货币应该用在已有支付方式解决不是很好的场景。Internet使得信息传输很容易，支付则难很多。 World Wide Currency 支付和信息传播联系在一起。</li>
<li>有人说：下一代互联网是Internet of value。Information can flow freely on the Internet，but payment cannot。趋势：价值交换和信息传播渠道相互融合。</li>
<li>有人说：加密货币的支付效率很低。</li>
<li>加密货币本来就不是和以前支付方式竞争</li>
<li>随着区块链的技术发展，共识协议改进，支付效率不断提高：比特币每秒7个交易，有的货币号称每秒达到100万个交易</li>
<li>最重要的一点：效率的好处应该在当前的历史环境下。电报Telegram在中国使用很长时间，因为没有更高效的方式。</li>
<li>智能合约的质疑：为啥不用法律合同，自然语言编写，智能合约是用程序编写的。Software is eating the world</li>
<li>ATM机是物理世界的智能合约，ATM刚开始出现故障</li>
<li>软件改变世界，这是一个大趋势</li>
<li>但，智能合约也不能解决所有问题。Democracy is the worst form of Government except for all those other forms that have been tried from time to time</li>
<li>Is decentralization always a good thing? 去中心化不能解决所有问题，</li>
</ul>
</li>
<li><p>敲重点</p>
<ul>
<li>不要被学术界的思维限制，不要被程序员的思维限制。</li>
<li>推荐书单：货币金融学</li>
<li>code is law （代码写到区块链中，是不能被更改的）</li>
</ul>
</li>
</ol>
<ul>
<li>参考资料</li>
</ul>
<ol>
<li>《Bitcoin and Cryptocurrency Technologies A Comprehensive Introduction》</li>
<li>以太坊白皮书、黄皮书、源代码</li>
<li>Sodility文档</li>
</ol>
<h2 id="关于区块链的一些整理_2019年12月">关于区块链的一些整理 2019年12月</h2><ul>
<li><p>Blockchain（实现了一个带有token的区块链）</p>
<ul>
<li>本质：保存持续增加的记录的分布式数据库。</li>
<li>问题：分布式数据中如何存储数据<ol>
<li>如何增加数据</li>
<li>如何修改数据</li>
</ol>
<ul>
<li>解决方案：增加和修改分离。<ul>
<li>如同记录log，不断记录新的数据，然后将这些数据记录下来</li>
<li>也即是LinkedList（链表就是最简单的区块链结构）</li>
</ul>
</li>
</ul>
</li>
<li>如何保存数据：数据和节点的管理和操作<ul>
<li>定义数据块</li>
<li>定义数据块之间的关系</li>
<li>添加数据块的功能</li>
<li>节点之间的通讯</li>
<li>节点之间同步数据</li>
<li>对节点的控制能力</li>
</ul>
</li>
<li>区块的结构是什么<ol>
<li>index </li>
<li>timestamp</li>
<li>data</li>
<li>hash</li>
<li>preivious Hash</li>
</ol>
</li>
<li>如何保证数据不被篡改<br>如何发现被篡改？      SHA256(index+previousHash+timestamp+data)<br>如何屏蔽这种情况？     都是<br>如何改回来？</li>
<li>如何创建第一个区块<br>硬编码，创世快。</li>
<li>如何创建一个新的块<br>依次计算</li>
<li>如何验证数据的有效性<ul>
<li>区块之间的索引是+1递增的</li>
<li>当前区块的previous hash需要和之前区块的Hash相同</li>
<li>区块自身的Hash需要正确</li>
</ul>
</li>
<li>区块分叉怎么办？<br>选择最长的那个链</li>
<li>节点之间如何通讯<br>达成共识的三个能力：<ol>
<li>当一个节点创建了一个区块，需要通知整个网络</li>
<li>当一个节点连接上了一个新的节点，需要主动询问对方最新的区块</li>
<li>当一个节点遇到一个新的区块，它会根据判断的结果向网络请求更多的区块（广播，类似gossip协议）</li>
</ol>
</li>
<li>如何控制节点<br>对外接口<br>查看节点的区块，添加区块，查看连通的节点，添加节点。</li>
<li>系统的架构<br>Blockchain：<ul>
<li>HTTP接口（控制节点）</li>
<li>Websocket接口（和其他节点进行P2P通信）</li>
</ul>
</li>
<li><p>如何应对攻击</p>
<ul>
<li>Proof-Of-Work原理：认的是计算能力，难题的解答过程就称为挖矿。（Hash的前n位数为0，Block中有一个nonce，不断增加nonce，直至达到难度条件）</li>
</ul>
</li>
<li>如何确定难度<ul>
<li>多久产生一个区块？bitcoin：10分钟；Ethereum：10-20秒</li>
<li>多久调整一次难度？bitcoin：2016个区块；Ethereum：动态调整</li>
</ul>
</li>
<li><p>时间戳被篡改了怎么办？</p>
<ul>
<li>判断之前的block的时间戳之差是否大到一定程度</li>
</ul>
</li>
<li><p>低难度长链（恶意节点产生一个低难度的长链）</p>
<ul>
<li>“中本聪共识”：中本聪提出：比较两条链，不能比较其长度，而是要比较其计算复杂度（hash算力）</li>
</ul>
</li>
</ul>
</li>
<li><p>小结：如何应对攻击？</p>
<ul>
<li>难于计算，易于验证，因此寻找特定前缀SHA256成为一个很好的难题</li>
<li>已经在代码中加入了难度，并且节点可以通过挖矿把区块添加到区块链中。</li>
</ul>
<ul>
<li>如何交易？<ul>
<li>金融体系的核心概念：所有权+交易权</li>
<li>如何证明你是你：私玥签名，公钥验证</li>
</ul>
</li>
<li>如何记录一次交易<ul>
<li>从哪里来：发送者地址（发起者比接受者多一个签名）</li>
<li>到哪里去：接收者地址</li>
<li>交易多少：数量</li>
</ul>
</li>
<li>如何唯一表示一次交易<br>hash：SHA-256</li>
<li>如何对交易进行签名（防止重放攻击）</li>
<li>如何找到用户拥有的token<br>查询交易，找到没有花掉的token，用这个进行交易</li>
<li>如何更新未花费的数据信息<br>当新的区块产生时，这个区块包含新的交易信息，因此，需要从新的区块中找到所有未花费的token的信息</li>
<li>如何更新所有未花费的信息</li>
<li>如何验证交易的有效性<ul>
<li>交易结构异常检查</li>
<li>交易id异常检查</li>
<li>同时判断token是否被花费掉（block中存有交易信息，所有未花费的存储在array中，更新这个array即可）</li>
</ul>
</li>
</ul>
</li>
<li><p>区块链的token最初从哪里来<br>  系统给“挖矿”的矿工的奖励，奖励和区块是绑定的，保存这些奖励：用区块的id</p>
<ul>
<li><p>小结：交易中记录未花费的数量和主人。</p>
</li>
<li><p>如何实现钱包？<br>钱包的三个功能</p>
<ul>
<li>创建钱包（公钥表示钱包。先产生私钥，再用私钥产生公钥。私钥的存储需要注意安全）</li>
<li>查看钱包的余额（未花费交易求和即可。filter地址相同的，map到amount，再求和—-很漂亮的写法）</li>
<li>在钱包之间进行交易（eg，自己50—40给别人+10给自己。n对n的过程）</li>
</ul>
</li>
<li>如何使用钱包<br>构建一个外部接口</li>
<li>如何找别人帮忙：交易费</li>
<li>如何保存未确认单的交易：交易池</li>
<li>如何通知他人交易信息<br>gossp协议。所以需要构建两个消息：查询交易池，反馈交易池。</li>
<li>如何防止重放攻击<ul>
<li>签名</li>
<li>交易不能被两次花费</li>
</ul>
</li>
<li>如何把未确认的交易放入区块中<ul>
<li>一个未确认交易已经加入新的区块</li>
</ul>
</li>
<li>一个未花费的交易在新的区块已经被花费掉</li>
<li>小结 如何找别人帮忙<br>找别人计算的包中附带一个50美元或者gas（以太坊中）</li>
</ul>
</li>
<li><p>如何实现用户界面</p>
<ul>
<li>查询区块和交易详细信息的接口</li>
<li>查询特定地址详细信息的借口</li>
</ul>
</li>
<li><p>Ethereum</p>
<ul>
<li>Ethereum本质上是一个图灵机，通过编写协议来驱动状态的改变</li>
<li>图灵机：状态和状态转移</li>
<li>核心功能：所有权，交易，状态转移</li>
<li><p>如何防止有人长时间占用节点？需要付费</p>
</li>
<li><p>版本：go-Ethereum</p>
</li>
<li>solidity实现：能编译成EVM执行的ByteCode的高级语言</li>
<li>Mist：Ethereum的应用查看器</li>
</ul>
</li>
</ul>
<ul>
<li>Blockchain(存储)—&gt;Bitcoin(记账方式)—&gt;Ethereum（计算）<br>Blockchain(存储)—&gt;Bitcoin(交易)—&gt;Ethereum（contract实现的图灵计算）</li>
<li>图灵机的本质<br>计算机的本质就是一堆状态（数据），状态之间相互转换。</li>
<li>p2p和Bitchain,BTC,Ethereum的一个区别：部分副本（N=3）和全副本</li>
<li><p>支撑区块链的核心是：人们对区块链的信心</p>
</li>
<li><p>Javascript语言：凡是能被JS写的，最终都被JS写。</p>
</li>
<li><p>参考</p>
<ol>
<li><a href="https://github.com/Fabsqrt/BitTigerLab/blob/master/Blockchain/Classes/Blockchain/README.md" target="_blank" rel="noopener">如何实现区块链</a></li>
<li><a href="https://github.com/Fabsqrt/BitTigerLab/blob/master/Blockchain/Classes/Ethereum/README.md" target="_blank" rel="noopener">如何实现以太坊Ethereum</a></li>
</ol>
</li>
<li><p>推荐书籍</p>
<ul>
<li>“python 哲学”</li>
<li>“Ethereum 哲学”</li>
</ul>
</li>
</ul>
<h2 id="《数学之美》_吴军_2017年12月">《数学之美》 吴军 2017年12月</h2><p><img src="《数学之美》读书笔记思维导图byDSZ.png" alt="《数学之美》读书笔记思维导图byDSZ"></p>
<p><img src="assets/数学之美/《数学之美》读书笔记思维导图byDSZ.png" alt="《数学之美》读书笔记思维导图byDSZ"></p>
<p><a href="https://zh.wikipedia.org/zh/%E7%BE%85%E5%A1%9E%E5%A1%94%E7%9F%B3%E7%A2%91" target="_blank" rel="noopener">罗塞塔石碑</a></p>
<ul>
<li><p>自然语言处理的历史</p>
<ul>
<li>图灵测试 Turning Test：1950年，阿兰图灵《mind》</li>
<li>60年的历史：</li>
<li>1950-1970s：用电脑模拟人脑（证明是不成功的，弯路）</li>
<li>1970s-至今：基于数学模型和统计</li>
<li>1956年8月31日 John McCarthy, Marvin Minsky, Nathaniel Rochester, Claude Elwood Shannon， <a href="https://zh.wikipedia.org/wiki/%E8%BE%BE%E7%89%B9%E7%9F%9B%E6%96%AF%E4%BC%9A%E8%AE%AE" target="_blank" rel="noopener">达特矛斯会议
</a><br>Herbert Simon, Allen Newel</li>
<li>1970s的基于统计方法的核心是：通信系统+隐马尔可夫模型</li>
<li>基于有向图的统计模型：解决复杂度的句法分析<ul>
<li>Frederick Jelinek领导：IBM-约翰霍普金斯系统</li>
<li>米奇 马库斯领导：宾夕法尼亚大学</li>
<li>统计语言模型：Frederick Jelinek，一个句子是否合理，就看它的可能性大小如何。  </li>
</ul>
</li>
</ul>
</li>
<li><p>Andrey Markov 马尔科夫假设：任何一个词只和前面一个词有关</p>
</li>
<li><p>训练统计语言模型的艺术在于解决好统计样本不足时的概率估计问题</p>
</li>
<li><p>1953年 I.J.Good和Alan Turning: Good-Turning Estimate</p>
</li>
<li><p>分词方法：查字典</p>
</li>
<li><p>消除分词的二义性问题：1990年郭进博士（清华大学电子工程系）：统计语言模型<br><img src="assets/数学之美/数学之美_读书笔记_消除分词的二义性.png" alt="数学之美_读书笔记_消除分词的二义性"></p>
</li>
<li><p>雅格布森（Roman Jokobson）六个要素：发送者（信息源），信道，接收者，信息，上下文和编码。</p>
</li>
<li><p>19世纪俄罗斯数学家马尔可夫（Andrey Markov），美国数学家鲍姆（Leonard E. Baum）于1960-70提出马尔可夫模型（Hidden Markov Model）；对应的训练方法：鲍姆-韦尔奇算法。</p>
<ul>
<li><p>马尔可夫假设：</p>
</li>
<li><p>马尔可夫链（马尔可夫过程）：符合马尔可夫假设的随机过程。</p>
</li>
<li><p>隐含马尔可夫模型三个基本问题：</p>
<ol>
<li>给定一个模型，如何计算某个特定输出序列的概率？<ul>
<li>Forword-Backward算法（Frederick Jelinek《Statistical Methods for Speech Recognition》）</li>
</ul>
</li>
<li>给定一个模型和某个特定的输出序列，如何找到最可能产生这个输出的状态序列<ul>
<li>维特比算法</li>
</ul>
</li>
<li>给定足够量的观测数据，如何估计隐含马尔可夫模型的参数<br><img src="assets/数学之美/数学之美-01.png" alt="image-20200115144740677"></li>
</ol>
</li>
<li><p>仅仅通过大量观测得到的信号 $O<em>1,O_2,O_3,\cdots$就能推算模型参数$P(S_t|S</em>{t-1})$和$P(Q<em>t|S</em>{t})$，这类方法称为无监督的训练方法。其中主要使用的鲍姆-韦尔奇算法（Baum-Welch Algorithm）。这个过程也称为期望值最大化（Expectation Maximum），简称EM过程，EM过程保证算法一定能收敛到一个局部最优解。（凸函数：则可以获取全局最优解；目标函数：输出概率）</p>
</li>
<li><p>解决翻译中的二义性问题（P68 互信息）</p>
<ul>
<li><p>William Gale,Kenneth Church, David Yarowsky从大量文本中找出总统布什一起出现的互信息最大的一些词，看上下文中哪类相关的词多即可。</p>
</li>
<li><p>相对熵（交叉熵）：Kullbak-Leibler Divergence 用来衡量相关性，但和变量的互信息不同，它用来衡量两个取值为正数的函数的相关性。</p>
</li>
<li><p>相对熵的三条结论：</p>
<ul>
<li><p>对于两个完全相同的函数，它们的相对熵等于零。</p>
</li>
<li><p>相对熵越大，两个函数差异越大，反之，相对熵越小，两个函数的差异越小。</p>
</li>
<li><p>对于概率分布或概率密度函数，如果取值均大于零，相对熵可以度量两个随机分布的差异性。</p>
<p>为了让其对称，詹森和香农提出一种新的相对熵的计算方法：</p>
</li>
</ul>
</li>
<li><p>Google自动问答系统：使用詹森-香农度量来衡量两个答案的相似性</p>
</li>
</ul>
</li>
<li><p>词频率-逆向文档频率（TF-IDF）</p>
<ul>
<li>贾里尼克从条件熵和相对熵出发，定义了一个称为语言模型复杂度（perplexity）的概念，直接衡量语言模型的好坏。</li>
<li>李开复 Sphinx语音识别系统：若不用任何语言模型（即零元语言模型）：复杂度997<br>若（二元）语言模型只考虑前后词的搭配，不考虑搭配的概率，复杂度为60；考虑搭配的概率，复杂度为20。</li>
<li>Ref 斯坦福大学托马斯.科弗（Thomas Cover）《Elements of Information Theory》</li>
</ul>
</li>
<li><p>波尔L.Bahl 著名的语音识别Dragon公司创始人贝克夫妇Jim Baker &amp; Janet Baker，解决最大熵迭代算法：达拉.皮垂（S.Della Pietra和V.Della Pietra）BCJR算法的另外两个提出者：库克（J.Cocke），拉维夫（J.Raviv）。第一个提出机器翻译统计模型：布朗（Peter Brown）、拉法特（John Laffety）</p>
</li>
<li><p>语音识别问题：人工智能和模式匹配问题—-&gt;通信问题。<br>贾尼尼克：两个隐含马尔可夫模型（声学模型+语言模型）<br>霍普金斯大学：世界著名的CLSP（Center for Language and Speech Processing）<br>Google 研究院院长诺威格（Peter Norvig），费尔南多.皮耶尔（Fernando Pereira）<br>Google搜索质量第一技术负责人：阿米特.辛格（Amit Singhal）</p>
</li>
<li><p>搜索的“道”：自动下载尽可能多的网页，建立快速有效的索引，根据相关性对网页进行公平准确的排序<br>下载-索引-排序。<br>最简单的索引结构是用一个很长的二进制数表示一个关键字是否出现在每篇文献中。对于互联网的搜索引擎来讲，每一个网页就是一个文献。</p>
</li>
</ul>
</li>
<li></li>
<li><p>网络爬虫：Web Crawlers，从任何一个网页出发，用图的遍历算法，自动访问到每一个网页并把它们存起来。<br>世界上第一个网络爬虫是由麻省理工学院的学生马休.格雷(Matthew Gray)1993年写成，起名“互联网漫游者”(WWW Wanders)<br>在网络爬虫中，使用一种“散列表”（Hash Table哈希表）而不是一个记事本，记录网页是否下载过的信息。</p>
</li>
<li><p>网络爬虫的工程要点：</p>
<ol>
<li>网络爬虫对网页遍历的次序：调度系统（Scheduler）优先级序列（Priority Queue）。BFS的成分多一些。</li>
<li>页面的分析和URL的提取：HTML方便提取，而用脚本语言（Javascript）写的网页不好提取，需要做浏览器内核的工程师来写网络爬虫的刷新程序。</li>
<li>记载哪些网页已经下载过的小本本—-URL表：采取散列表，解决散列表的通信问题<br>首先，明确每台下载服务器的分工；<br>其次，在明确分工的基础上，判断URL是否下载：批处理。</li>
</ol>
</li>
<li><p>PageRank算法（网页排名算法）<br>高明之处：将互联网当作一个整体看待。<br>如果一个网页被很多其他网页所链接，说明它受到普遍的承认和信赖，那么它的排名高。<br>A已知，B未知，待求。<br>假定$B<em>i$是第i次迭代后的结果，那么$B_i=A \cdot B</em>{i-1}$，初始假设：所有的网页排名都是$\frac{1}{N}$,即$B<em>0=(\frac{1}{N},\frac{1}{N},\cdots,\frac{1}{N})$，最终$B_1,B_2,\cdots,B_i$会收敛，无限趋向于B，此时$B=B \times A$。当两次迭代的结果$B_i$和$B</em>{i-1}$差异很小时，接近于零，停止迭代，算法结束。一般，10次左右迭代基本收敛。<br>注：由于网页之间的链接的数量比互联网的规模非常稀疏。因此，计算网页的网页排名也需要对零概率或小概率事件进行平滑处理，网页的排名是一个一维向量。$B<em>i=[\frac{\alpha}{N}+(1-\alpha)A]\cdot B</em>{i-1}$，$\alpha$是一个较小常数。 </p>
</li>
<li><p>Amit Singhal, Matt Cutts, Martin Kaszkiel, 吴军四个人研究网络搜索中的作弊问题Spam。</p>
</li>
<li><p>如何确定网页和查询的相关性<br>TF(Term Frequency) 单文本词频<br>在信息检索中，使用最多的权重是“逆文本频率指数” IDF(Inverse Document Frequency)</p>
<p>IDF：一个特定条件下关键词的概率分布的交叉熵(Kullback-Leibler Divergen)<br>相关性计算：$TF_1 \cdot IDF_1 + TF_2 \cdot IDF_2 + \dots + TF_N \cdot IDF_N$</p>
</li>
<li><p>有限状态机和动态规划—-地图和本地搜索的核心技术<br>基于概率的有限状态机<br>前AT&amp;T实验室的三位科学家，莫瑞(Mehryar Mohri)，皮耶尔（Fernando Pereria），瑞利（Michael Rily）：通用的基于概率的有限状态机C语言工具库。<br>Google Now的引擎和有限状态的工具库，功能上完全等价。<br>全球导航的关键算法是图论中的动态规划（Dynamic Programming）。</p>
</li>
<li><p>新闻的自动分类（余弦定理）<br>词汇表中有64000个单词，将对应TF-IDF值作为特征向量，用向量的角度来度量两个向量的相似性<br>$cosA=\frac{b^2+c^2-a^2}{2bc} \Rightarrow cosA=\frac{<b,c>}{|b|\cdot|c|} \Rightarrow  cos\theta=\frac{x<em>1y_1+x_2y_2+\dots+x</em>{64000}y<em>{64000}}{\sqrt{x_1^2+x_2^2+\dots+x</em>{64000}^2} \cdot \sqrt{y<em>1^2+y_2^2+\dots+y</em>{64000}^2}}$</b,c></p>
</li>
<li><p>自然语言处理过程中，最常见的两个分类问题：</p>
<ol>
<li>将文本按主题分类（举例：介绍奥运会——&gt;体育类）</li>
<li>将词汇表中的词按意思归类（各种运动的项目名称——&gt;体育类）：通过矩阵圆满一次性的解决。</li>
</ol>
</li>
<li><p>分类其实是一种聚类问题<br>新闻——&gt;实词——&gt;数——&gt;向量——&gt;夹角<br>矩阵运算中的奇异值分解（Singular Value Decomposition SVD）<br>N个词，M篇文章，每行对应一篇文章，每列对应一个词。<br>$A=\left[<br>\begin{array}<br>{ccc}<br> a<em>{11} \cdots a</em>{1j} \cdots a<em>{1N} \<br> \cdots  \<br> a</em>{i1} \cdots a<em>{ij} \cdots a</em>{iN} \<br> \cdots \<br> a<em>{M1} \cdots a</em>{Mj} \cdots a<em>{MN} \<br>\end{array}<br>\right]$ 其中，$a</em>{ij}$是第j个词在第i篇文章中出现的加权词频（比如TF-IDF）。<br>奇异值分解，就是把这个大矩阵分解成三个小矩阵相乘。<br>$A<em>{1000000 \times 500000}=X</em>{1000000 \times 100} B<em>{100 \times 100} Y</em>{100 \times 500000}$<br>X是词进行分类的结果：每一行表示一个词，每一列表示一个语义相近的词类（语义类）</p>
<p>Y是对文本的分类结果：每一列对应一篇文本，每一行对应一个主题<br>B表示词的类和文章的类之间的相关性<br>2017年 Google中国的张智威博士：奇异值分解的并行算法。<br>$A<em>{MN}=X</em>{MM} \times B<em>{MN} \times Y</em>{NN}$ ，其中X为酉矩阵，Y为酉矩阵的共轭矩阵。（酉矩阵定义：与其共轭矩阵相乘等于单位阵的矩阵）</p>
</li>
<li><p>奇异值分解步骤：</p>
<ol>
<li>将A变换成一个双对角矩阵，计算量是$O(MN^2)$</li>
<li>将双对角矩阵变成奇异值分解的三个矩阵。</li>
</ol>
</li>
<li><p>信息指纹算法：梅森旋转算法（Mersenne Twister）、MD5、SHA-1。</p>
</li>
<li><p>集合相同的判定：Google的工作：为了允许一定的容错能力，采用了一特定的信息指纹相似哈希（SimHash）。<br>Google实验室项目，CopyCat项目：可以准确找出原文和转载的文章。</p>
</li>
<li><p>Youtube的反盗版、视频匹配：关键帧的提取和特征的提取；信息指纹表示关键帧；检测是否盗版类似于比较两个集合元素是否相同。</p>
</li>
<li><p>计算权威度的步骤：</p>
<ol>
<li>对网页每句话进行句法分析，找出涉及到主题的短语，以及对信息源的描述，获得了“提及”信息。</li>
<li>利用互信息，找到主题短语和信息源的相关性。</li>
<li>对主题短语进行聚合。</li>
<li>需要对一个网站中的网页进行聚合，比如把一个网站下面的网页按照子域或子目录进行聚类。</li>
</ol>
</li>
<li></li>
<li><p>最大熵（Maximum Entropy）模型：保留全部的不确定性，将风险降到最低。对一个随机事件的概率分布进行预测时，我们的预测应当满足全部已知的条件，而对未知的情况不要做任何主观假设。</p>
<ul>
<li>匈牙利著名数学家、信息论最高奖得主希萨（I.Csiszar）证明，对任何一组不自相矛盾的信息，这个最大熵模型不仅存在，而且是唯一的。此外，它们都有一个非常简单的形式——指数函数。</li>
<li><p>第一个在实际信息处理应用中验证了最大熵模型的优势是宾夕法尼亚大学马库斯教授的高徒拉纳帕提（Adwait Ratnaparkhi）。</p>
</li>
<li><p>最原始的最大熵模型的训练方法：通用迭代算法GIS(Generalized Iterative Scaling)：J.N.Darroch,D.Ratcliff 1970。</p>
<ol>
<li>假定第零次迭代的初始模型为等概率的均匀分布。</li>
<li>用第N次迭代的模型来估算每种信息特征在训练数据中的分布，如果超过了实际的，就把相应的模型参数变小。否则变大。</li>
<li>重复步骤2直至收敛。</li>
</ol>
</li>
<li>改进迭代算法（IIS Improved Iterative Scaling）达拉皮垂孪生兄弟 1980：使最大熵模型的训练时间缩短了一到两个数量级。（世界上最成功的对冲基金Hedge Fund公司，文艺复兴技术公司Renaissance Technologies）</li>
<li>小结：最大熵模型是唯一一种既能满足各个信息源的限制条件，又能保证平滑性的模型。但是，最大熵模型的计算量巨大，在工程上实现方法的好坏决定了实用与否。</li>
</ul>
</li>
<li><p>线性插值的模型比最大熵模型效果略差，但是能得到80%的收益。Google拼音输入法的个性化语言模型就是这么实现的。$P’(w<em>i|w</em>{i-1})=\lambda(w<em>{i-1}) \cdot P_0(w_i|w</em>{i-1}) + (1-\lambda(w<em>{i-1})) \cdot P_0(w_i|w</em>{i-1})$</p>
</li>
<li><p>布莱尔：基于变换规则的学习方法（Transformation Rule Based Machine Learning）</p>
</li>
<li><p>布隆过滤器：Burton Bloom<br>电子邮件X，用8个不同的随机数产生器$(F_1,F_2,\cdots,F_8)$产生8个指纹$(f_1,f_2,\cdots,f_8)$，再用一个随机数产生器G把这个8个信息映射到1-16亿中的8个自然数$g_1,g_2,\cdots,g_8$，把这8个位置的比特位全部设置为1。<br>应用：检测一个电子邮件是否在黑名单中？$Y\rightarrow s_1,s_2,\dots,s_8 \rightarrow8个比特位：t_1,t_2,\dots,t_8$，若Y在黑名单中，则$t_1,t_2,\dots,t_8$对应的8个比特值是1。</p>
<ul>
<li>布隆过滤器的识别问题：$(1-e^{-\frac{kn}{m}})^k$，m比特，含有n个元素。m=16，k=8，假阳性的概率为万分之五。</li>
</ul>
</li>
<li><p>贝叶斯网络：也称为信念网络（Belief Networks）<br>使用贝叶斯网络必须先确定其拓扑结构，然后还要知道各个状态之间相关的概率。<br>得到拓扑结构和这些参数的过程分别叫做结构训练和参数训练，统称训练。从理论上讲，它是一个NP(NP-Complete)完备问题。IBM华生实验室的茨威格博士（Geoffrey Zweig）和西雅图华盛顿大学的比尔默教授（Jeff Bilmer），完成了一个通用的贝叶斯网络的工具包。</p>
<ul>
<li>主题模型（Topic Model）：用基于统计的模型分析文本，抽取概念，分析主题。Google的Rephil，文本分类：用贝叶斯网络建立一个文章、概念和关键词之间的联系。</li>
<li>贝叶斯网络的训练：<br>使用贝叶斯网络首先要确定它的结构。<br>复杂一点的问题：无法人工给出结构，需要通过机器学习得到。</li>
<li>例子：美国洛杉矶警察局 $P(l,t,c)$，$l,t,c$分别代表地点，时间和犯罪类型。<br>$P(l,t,c|X)=\frac{P(l,t,c,X)}{P(X)}$，P(X)：历史数据估算，X：人流，活动，天气，失业率。<br>根据历史数据逐步提取各种特征：比如演出和偷盗的关系。</li>
</ul>
</li>
<li><p>条件随机场：非常灵活的用于预测的统计模型。</p>
</li>
<li><p>维特比算法（Andrew Viterbi）是一个特殊但应用最广的动态规划算法。利用动态规划，可以解决任何一个图中的最短路径问题。维特比算法是一个针对特殊的图—-篱笆网络（Lattice）的有向图最短路径问题而提出的。<br>之所以重要，是因为凡是使用隐含马尔可夫模型描述的问题，都可以用维特比算法解码。</p>
<ul>
<li>$P(x<em>i|x</em>{i-1})$为状态的转移概率，$P(y_i|x_i)$为每个状态的产生概率</li>
<li>首先，根据现有的模型，计算各个观测数据输入到模型中的计算结果，这个过程称为期望值计算过程（Expecation）或E过程；</li>
<li>接下来，重新计算模型参数，以最大化期望值。这个过程称为最大化的过程（Maximization），或M过程。EM算法。</li>
<li>EM算法包括：隐含马尔可夫模型的训练方法：Baum-Welch算法；最大熵训练方法：GIS算法。</li>
<li>EM算法不一定获得全局最优解。若优化的目标函数是一个凸函数，则可以获得全局最优解。熵函数：是凸函数。余弦距离：不是凸函数。</li>
</ul>
</li>
</ul>
<ul>
<li>数学相关<ul>
<li>布尔代数对于数学的意义等同于量子力学对物理学的意义，它们将我们对世界的认识从连续状态扩展到离散状态。布尔代数非常简单，但是对数学和计算机发展的意义重大，它不仅把逻辑和数学合二为一，而且给了我们一个看待世界的全新视角，开创了今天数字化的时代。</li>
<li>数据库的查询语句（SQL）支持各种复杂的逻辑组合，但是背后的基本原理是基于布尔运算的。</li>
<li>离散数学是当代数学的一个重要分支，也是计算机科学的基础。它包括：数理逻辑（基于布尔运算），集合论，图论，近世代数四个分支。<br>图论的开始：欧拉（Leonhard Euler）哥尼斯堡的七座桥。广度优先搜索 BFS Breadth-First Search，深度优先搜索 DFS Depth-First Search。</li>
<li>数学模型的几个结论：<ol>
<li>一个正确的数学模型应当在形式上是简单的。</li>
<li>一个正确的模型一开始可能还不如一个精雕细琢过的错误模型来的准确，但是，如果我们认定大方向是对的，就应该坚持下去。</li>
<li>大量准确的数据对研发很重要。</li>
<li>正确的模型也可能受到噪声干扰，而显得不准确。这时候不要以一种凑合的修正方法加以弥补，而是要找到噪声的根源，这也许能通往重大的发现。</li>
</ol>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>透过现象看本质</p>
<ul>
<li>信息的冗余是信息安全的保障</li>
<li>语言的数据，称之为语料，尤其是双语或者多语的对照语料对翻译至关重要，它是从事机器翻译研究的基础。 </li>
<li>“智能”有关的问题，都可以归结为一个多维空间进行模式分类的问题。</li>
<li>人工神经网络：本质上是一种特殊的有向图。</li>
<li>在人工神经网络中，需要设计的部分只有两个：<ul>
<li>一是它的结构。（网络分几层，每层几个节点，节点之间如何连接）</li>
<li>二是非线性函数$f(\cdot)$的设计。（常用的指数函数）</li>
</ul>
</li>
<li>如何学习语言：（宾西尼亚大学的语言数据库(LDC)标准） <ul>
<li>语法规则（Grammar Rules）</li>
<li>词性（Part of Speech）</li>
<li>构词法（Morphologic）</li>
</ul>
</li>
<li>Donald Knuth(图灵家得主)用计算机复杂度来衡量算法的耗时</li>
<li>语言和编码的关系，算法和语法规则的关系：任何一种语言都是一种编码方式，而语言的语法规则是编解码的算法。</li>
<li>几乎所有的自然语言处理问题都可以等价成通信的解码问题。</li>
</ul>
</li>
<li>人物<ol>
<li>自然语言处理的关键人物：Frederick Jelinek和他领导的IBM华生实验室(T.J.Watson)</li>
<li>Amit Singhal 做事哲学：帮助用户解决80%的问题，再慢慢解决剩下的20%问题，是在工业界成功的秘诀之一。</li>
<li>柯林斯：做事做到极致。工业界—-&gt;学术界。</li>
</ol>
</li>
</ul>
<ul>
<li>观点<ol>
<li>小学生和中学生其实没必要花那么多时间读书，而他们的社会经验、生活能力以及在那时树立起的志向将帮助他们的一生。</li>
<li>中学阶段花很多时间比同伴多读的课程，上大学阶段用很短的时间读完。</li>
<li>学习和教育是持续一辈子的事情。</li>
<li>书本的内容可以早学，也可以晚学，但错过了成长阶段却是无法弥补的。</li>
<li>作者一直认为，一个人想要在自己的领域内做到世界一流，他的周围必须有非常多的一流人物。（why？带辩论思考）</li>
<li>追求术的人一辈子很辛苦，只有掌握了本质和精髓的人才游刃有余。</li>
<li>真正做好一件事没有捷径，离不开一万小时的专业训练和努力。</li>
<li>简单性和模块化是软件工程的基石</li>
<li>分布式和容错性是互联网的生命</li>
</ol>
</li>
<li>推荐书单<ol>
<li>美籍俄裔物理学家：乔治伽莫夫《从一到无穷大》</li>
<li>罗曼罗兰《巨人三传》、《贝多芬传》、《米开朗基罗传》、《托尔斯泰传》</li>
<li>斯坦福大学 Daphne Koller：《Probabilistic Graphical Models: Principles and Techniques》</li>
</ol>
</li>
</ul>
<h2 id="高级项目管理培训_2017年6月14日">高级项目管理培训 2017年6月14日</h2><p><img src="assets/高级项目管理/高级项目管理笔记.png" alt="高级项目管理笔记" style="zoom:25%;"><br><img src="高级项目管理笔记.png" alt="高级项目管理笔记"></p>
<p><a href="http://baike.baidu.com/item/%E8%B0%A2%E6%96%B0%E5%8D%8E/3280598" target="_blank" rel="noopener">主讲老师谢新华</a>不仅告诉方法，更重要的是告诉怎么思考。</p>
<p>我的总结：</p>
<ol>
<li>项目管理的方法论：分割和反馈。分割借鉴微积分的思想：分而治之，并集中火力突破，团队要分成小组，计划分割成多个里程碑。反馈是要有修正，其实就是学习的过程，不断改进自己的计划，不断前进，其实和人生道路的前进如此一致。 </li>
<li>项目管理对待团队的核心：信任，分享，共同进步。一个好的产品交付时，不仅仅是交付一个产品，更是交付一个团队，团队中的每个人都得到提高和进步，甚至快速成长，这就是项目经理创造出氛围的意义。</li>
<li>其中的一些值得注意的观点：<ul>
<li>大人取于义，小人趋于利</li>
<li>沟通代表着尊重</li>
<li>只有更好的团队，没有更好的个人</li>
<li>做事情：分解成单独的小任务，全力以赴解决，然后再返回重新解决另外一个或者一层任务</li>
<li>决策的核心是取舍 </li>
<li>高级的含义：Senior，工作经验，管理创新。</li>
<li>成本：直接成本；间接成本（不去干的损失）。</li>
<li>所有的项目都是临时的。</li>
<li>开会最重要的是：立规！</li>
</ul>
</li>
</ol>
<h2 id="礼悟会员课程：“艾比克英语”创始人陈序讲座_2019年11月">礼悟会员课程：“艾比克英语”创始人陈序讲座 2019年11月</h2><p>听完了这个，觉得这个经验值一个亿。自己总结一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">任何事情基本上是这个路径：方法对了，重复+练习。</span><br><span class="line"></span><br><span class="line">3-7岁是语音敏感期。</span><br><span class="line">输入：最重要的是输入，而且要是：可理解输入。</span><br><span class="line">量要够：700-1000小时，小学毕业前。</span><br><span class="line">自然拼读：有一个前提，要有600个单词的词汇量。</span><br><span class="line">拼音和英语不能同时教。</span><br><span class="line"></span><br><span class="line">RAZ分级阅读+口语会话：精读，输入要可理解式输入，跟读。</span><br><span class="line">精听：用口语会话（比如 &quot;sight word tales&quot;）作为学习材料。</span><br><span class="line">关于写：听+跟读是基础，最重要的。写之前要有：前写作训练。</span><br><span class="line">关于泛听：四年级之前不要泛听，所以英文动画片可以不看，英文歌曲也不是好的学习材料。</span><br></pre></td></tr></table></figure>
<h2 id="叩响英语学习大门（九个方面）">叩响英语学习大门（九个方面）</h2><ol>
<li><p>第二语言的习得关键期</p>
<ul>
<li>语言敏感期：3-7岁第二语言的获得能力最高。</li>
<li>早期英语三年级到四年级之前没有达到阅读水平，其科研水平和技能获得能力较差，并一生存在困惑（心理学研究结果）</li>
</ul>
</li>
<li><p>高效学习方法理论依据</p>
<ul>
<li>输入最重要：输入要足够，且有以下注意点。（kelasheng教授的输入假说）<ul>
<li>可理解输入：要孩子明白什么意思，不明白意思就是无效输入</li>
<li>输入量要足够：长期的3-12岁中国孩子跟踪，700-1000小时。如果达到这个水平，就是北京重点小学的英语水平前十名</li>
</ul>
</li>
<li>加拿大司特钠教授的输出假说：输入和输出之间有一个推动性的东西，建立一个桥梁：这个桥梁就是<strong>跟读</strong>。</li>
<li>总结该英语学习方法：<ul>
<li>可理解的输入：听+跟读</li>
<li>量化的输入累计：700-1000小时。同声翻译：练习2000小时。</li>
<li>学习小组：指导听和读的方法</li>
</ul>
</li>
</ul>
</li>
<li>学习材料的选择<ul>
<li>第二语言的版本</li>
<li>阅读绘本：英语学习机构的问题在于怎么使用，量化方法。分为：美国系列、英语系列和台湾系列。但一定要是<strong>分级</strong>阅读绘本。</li>
<li>儿歌不适合：孩子不理解。</li>
<li>动画片：本身不错，但精听不适合，孩子听不懂</li>
<li>自然拼读：<strong>必须有一个前提条件，至少600的单词词汇量。</strong></li>
<li>阅读课程：听说读写综合起来。选择的是：<strong>美国的RAZ阅读绘本。</strong></li>
</ul>
</li>
<li>磨耳朵方法<ul>
<li>精听是关键<br>比如“this” “these” “they” 容易混淆：可以读的长点。<br>带有腔调的句子，比如sorry? 先上后下的语调等。有浊音等方法。<br><strong>四年级之前不要泛听。</strong><br><strong>精听要用口语会话作为材料，用阅读绘本作为材料不好。（台湾学者实验：差4-6倍）</strong></li>
<li>重复多听</li>
<li>精听累计时间</li>
</ul>
</li>
<li>练嘴皮方法（跟读）<ul>
<li>模仿语音语调<br>跟读，反复对比。<br><strong>好处：往深的学之后，就体现出非常大的好处，比如老外的连读很多。</strong></li>
<li>跟读方法<br>值得注意的是：需要重复，因为要累计时间。</li>
<li>重复跟读</li>
<li>跟读累计时间</li>
</ul>
</li>
<li>学习效果</li>
<li>父母陪伴与坚持<ul>
<li>家长陪伴介入非常重要，特别是小学一年级的时候。（包括数学、钢琴等，比如朗朗的爸爸就比朗朗厉害）</li>
<li>家长可以解释意思，家长可以解释，因为懂得98%的意思才有效，<strong>可懂式输入</strong>。</li>
<li>情绪：有回应和反馈，令孩子感到情感的力量，这个任何老师都做不到。</li>
</ul>
</li>
<li>学习小组指导<ul>
<li>效果好，要有好老师+好方法。</li>
<li>误区：回家要有好方法，不仅仅是跟好老师（学习方法好）学习。</li>
<li>好学校：好老师+好孩子。好孩子是好家长培养出来的。</li>
<li>坚持打卡！一对一指导</li>
</ul>
</li>
<li>课程体验要求和方法</li>
</ol>
<p>外国孩子参加英语补习ESL，就可以参加本地孩子的英语学习。</p>
<h2 id="视频访谈_“美国奥数总教练罗博深访谈”_2019年10月18日">视频访谈 “美国奥数总教练罗博深访谈”  2019年10月18日</h2><ul>
<li>什么人能到最顶尖的地方？<br>有兴趣，并坚持把自己的时间都放进去的人。例如硅谷附近的一些公立学校可以很push，也可以上名校，但他们到不了最顶尖的地方。</li>
<li>他认为教育中的方法<ul>
<li>自己主动选择</li>
<li>管理好自己的时间</li>
</ul>
</li>
<li>学习奥数的用力点和方法<br>做题10分钟，先思考20分钟，想不通再去看答案中的一个关键概念，相当于一个提示，再思考。</li>
</ul>
<h2 id="书《为何家会伤人》_2019年10月">书《为何家会伤人》 2019年10月</h2><h2 id="视频课程《Learning_How_to_Learn》2017年9月22日">视频课程《Learning How to Learn》2017年9月22日</h2><p>学会如何学习：帮助你掌握复杂学科的强大智力工具<br>Learn how to learn?<br>美国加州大学圣地亚哥分校<br>Dr. Barbara Oakley 芭芭拉 奥克兰<br>如何封装信息？<br>记忆技巧<br>对付拖延症<br>掌握困难科目的方法</p>
<h3 id="第一周_什么是学习">第一周 什么是学习</h3><h4 id="集中思维和发散思维">集中思维和发散思维</h4><ul>
<li>番茄学习法：集中精力25分钟，休息5分钟</li>
</ul>
<h4 id="Robert_Bilder博士就创造力与问题解决能力进行的访谈">Robert Bilder博士就创造力与问题解决能力进行的访谈</h4><ul>
<li><p>性格最终会归结为5个方面（OCEAN）</p>
<ol>
<li>开放性 O</li>
<li>责任心 C</li>
<li>外向性 E</li>
<li>随和性 A 有时候坚持自己的观点的人，创造力可能更好</li>
<li>神经质 N</li>
</ol>
</li>
<li><p>人的一生都在平衡别人的评价和自己的看法。比如作家对读者的反馈</p>
</li>
<li>高效学习<ol>
<li>语言学习型</li>
<li>图像学习型</li>
<li>十的次方训练 powers of ten  从更高的角度看待问题，从问题中抽身出来，思考为什么要这么做，思考问题的大局时什么样的</li>
<li>睡觉：可能允许神经网络自行组装，导致发现解决问题的办法。我们的潜意识可能是无价之宝。</li>
</ol>
</li>
</ul>
<h4 id="《八步半轻松写作》作者达芙妮_www-publicationcoach-com">《八步半轻松写作》作者达芙妮 www.publicationcoach.com</h4><ol>
<li>写作障碍的斗争</li>
<li>专注模式：编辑大脑；发散模式：创造或写作模式。活跃，清醒的发散思维来驾驭写作时的大脑，方法：思维导图法。写作前不要提纲，要创造，创造新的链接。</li>
<li>记忆的价值被忽视了。一位伟大的诗人说过，去记住一首诗歌，因为它能帮助你更加深入的理解其中隐含的深意。</li>
<li>写作时最大的一个错误：边写边改。APP:writeordie.com “不写就死”</li>
</ol>
<h4 id="Benny_Lewis_爱尔兰多语种达人_全职语言黑客_memorise-com_助记法_APP：Anki">Benny Lewis 爱尔兰多语种达人 全职语言黑客 memorise.com 助记法 APP：Anki</h4><ul>
<li>计划七千英里横穿美国，已经走了两千英里</li>
<li>错误：炫耀。方法：热爱文化，和会这门语言的人交流</li>
<li>孩子们学习语言的优势：不怕罚错误</li>
<li>自我实现的预言：在西班牙21岁我告诉我自己，我年龄大到不能学语言了。Henry Ford 不管你认为你行还是不行，你都是对的。你学不会语言的真正原因：你太相信这些借口了。</li>
<li>Skype 练习基础对话；24小时听无线电广播</li>
</ul>
<h3 id="第二周_组块">第二周 组块</h3><ul>
<li>组块化是一种思维的跃进，根据意义将信息碎片拼接起来，而新的逻辑整体让组块更容易记忆，同时更容易让组块整合到所学内容的大框架下</li>
<li>只需要记住一个组块：我要穿衣服</li>
<li>小组块—&gt;大组块 将复杂的想法，动作和反应组成一个单独的组块</li>
<li>数学或者科学问题：关注步骤之间的联系</li>
<li>建立组块的一些基本方法：<ul>
<li>集中精力对组块化的信息</li>
<li>对建立组块的对象有基本的了解：只有在自己实际操作和完全掌握的情况下建立起的神经模型，你才能做得到</li>
<li>获取背景知识：明白什么时候用它，融合到框架中的位置</li>
</ul>
</li>
<li>能力错觉：<ul>
<li>Recall：回顾知识，看看自己记住了多少，来巩固练习，再一次努力记住其中的核心思想<ul>
<li>回顾知识：不是简单的复述，而是通过回顾这个过程加深理解</li>
</ul>
</li>
<li>思维导图：画出概念之间的联系</li>
<li>划线和高亮要谨慎！在空白处写笔记总结关键概念是一种很好的办法<ul>
<li>自测：确保你是不是真的学会了。 </li>
</ul>
</li>
<li>在常规学习场所以外回顾材料会帮助你加深对材料的理解</li>
</ul>
</li>
<li>是什么激励了你？<ul>
<li>学习自己感兴趣的东西很简单</li>
<li>神经递质是一种可以影响神经元如何回应其他神经元的化学物质<ul>
<li>acetylcholine 乙？胆碱：集中精力学习时</li>
<li>dopamine 多巴胺：当接受到一个毫无预期的奖励时，神经元分泌出多巴胺。快感缺乏：缺少多巴胺。严重缺乏将导致帕金森症，最终导致紧张症，完全缺乏行动的病症</li>
<li>serotonin 血清素：有力的影响你的社交生活，</li>
<li>杏仁核</li>
<li>情绪同样重要</li>
</ul>
</li>
</ul>
</li>
<li>组块库的价值<ul>
<li>增加头脑中组块的数量，有价值的信息</li>
<li>帮助理解新概念：物理里学到的概念和商学里的组块概念类似；语言学习和计算机编程类似</li>
<li>建立组块式图书馆：训练大脑不仅要认出一个特定的概念，还要认出概念的类别，以便你能够自如的知晓如何快速解决或处理你遇到的问题</li>
<li>理清头绪或解决问题的两种途径：<ul>
<li>一是顺序性的一步步推理；</li>
<li>二是通过整体性的直觉</li>
</ul>
</li>
<li>The Law of Serendipity:Lady Luck favors the one who tries.机遇定律：幸运女神会眷顾努力之人</li>
<li>第一个问题或者概念进入心理图书馆，第二个，第三个会逐渐容易</li>
</ul>
</li>
<li>过度学习，抑制，思维定势和交叉<ul>
<li>过度学习时有意义的，帮助使得行为自动化。但在某一阶段学会了一个基本概念，在这段时间内不断巩固它，并不能加强你所期许的</li>
<li>集中精力在学习的困难部分：刻意训练（deliberate practice），通常是好学生和优秀学生的差别所在</li>
<li>思维定势（Einstellung，德语，原义为思想模式）：最开始的一个想法可能会阻碍你发现更棒的主意或者解决方法</li>
<li>一个错误：在学会游泳前跳入水中。盲目的做作业，不看书，不上课，不看在线课程</li>
<li>掌握一门新学科：不仅要学习基础组块；更要学会如何选择和应用不同的组块</li>
<li>最佳学习方法：练习如何在需要不同技术和策略的问题以及情形中来回转换，这就是所谓的交替学习：能够帮助学习更加深入。</li>
<li>练习和重复：帮助建立稳固的神经模式；交替学习：能让大脑更具灵活性和创造性。这样才会开始独立思考，在一个学科内交替学习，在不同学科内交替学习，更容易在不同领域的组块间创造联系。</li>
</ul>
</li>
<li>MIT诺曼教授访谈<ul>
<li>MIT 工程院，大学和中学的一个差别：必须是团队的一员</li>
<li>挫败感：保持自我平衡，意识到自己当前的选择是合理的；</li>
<li>休息很重要，太努力会伤害大脑，休息的方法是放空，关闭大脑的意识思维，让潜意识工作起来。</li>
<li>系统性的获取信息，看，说，拼写。用不同的学习方式充盈自己。</li>
<li>给别人解释的时候说明哪些是你自己真的懂了</li>
<li></li>
</ul>
</li>
<li>斯考特 杨（Scott Young）堪称学习的终极探险家 一年时间自学完成了MIT计算机科学四年的全部课程，专注于一年的旅行 学习西班牙语，葡萄牙语，汉语和汉语<ul>
<li>在四个国家各待三个月</li>
<li>尽力做，比如做习题，遇到困难再解决</li>
<li>自我解释：查德费曼传记，遇到困难，仔细研究，白纸给别人解释，或者不能准确表达自己的想法时，就是你没理解的地方。</li>
<li>重中之重，是不能自欺欺人。</li>
<li>类比方法。数学和理学全部是纯抽象的概念：比喻的方法：伏特类比盛水的管道等。</li>
<li>挖掘学习的积极性：一点点学习提高兴趣</li>
<li>从失败中学习</li>
<li>制定明确的目标：尝试麻省理工学院的挑战；三个月学习一门语言</li>
<li>有效利用网络资源：MIT公开课内容很丰富；15美元去亚马逊买教材做习题；</li>
<li>通过少学来学到更多？集中精力，加大强度，自我检验反馈。学韩语花3-4小时每天，识字卡片，和老师对话这种高强度活动。</li>
</ul>
</li>
<li>艾米 阿尔康（Amy Alkon） 电台主持，记者，博客作者<ul>
<li>将专注模式和发散模式运用到写作和学习中去：利用碎片时间寻找灵感</li>
</ul>
</li>
</ul>
<h3 id="第三周_拖延症和记忆">第三周 拖延症和记忆</h3><ul>
<li>拖延和上瘾有类似之处：短暂的兴奋。拖延的长期影响：看上去只是拖延了一件非常小的事情，但是日积月累拖延就会成为习惯，虽然看上去也可以很健康，但长期影响呢？</li>
<li>僵尸意识无处不在：第一次倒车，组块的形成和习惯有关，习惯是我们的节能机制，节省能量。四个阶段：<ul>
<li>1.信号 Cue</li>
<li>2.惯式 Routine</li>
<li>3.奖励 Reward</li>
<li>4.坚信 Belief</li>
</ul>
</li>
<li>利用习惯的神奇力量来避免拖延<ul>
<li>克服一个习惯的诀窍就是改变你对某个信号的反应，番茄工作法十分有效</li>
<li>重置旧习惯的关键是制订一个计划</li>
<li>计划完成时给自己一些奖励</li>
<li>相信新的习惯能够奏效这一信念可以让你坚持下去</li>
</ul>
</li>
<li>应对生活和学习<ul>
<li>结果导向：记下本周重点工作列表；睡前在前一晚写下任务清单，征召僵尸帮你完成第二天列表的项目</li>
<li>过程导向：在列表中穿插一些锻炼身体的任务，比如打扫卫生。</li>
<li>完成目标的时间：下午5点之前。学习专家之一卡尔纽波特(Cal Newport)基本上他的整个学生生涯都在5点之前结束学习的，最后从MIT获得博士学位。</li>
<li>一醒来就完成至少一个番茄时间：尽量先开始最重要且最讨厌的工作</li>
</ul>
</li>
<li>小结<ul>
<li>Keep a planner journal 日积月累坚持</li>
<li>Commit yourself to certain routines and tasks each day 每天规定一些日常和任务</li>
<li>Delay rewards until you finish the task 有意识的把奖励留到完成任务之后</li>
<li>Watch for procrastination cues 留意诱发拖延的信号</li>
<li>Gain trust in your new system 对你的新体系产生依赖（尽力待在一个没有拖延诱发信号的新环境中，比如图书馆中的一个安静角落）</li>
<li>Have backup plans for when you still procrastinate 制订备用计划</li>
<li>Eat your frogs first 每天先处理困难的工作</li>
</ul>
</li>
<li>深入探索记忆<ul>
<li>出色的视觉体系和独特的神经系统有助于构建部分长时记忆</li>
<li>大脑天生就擅长记忆不同地点的概况</li>
<li>充分发挥视觉和空间记忆能力，你的记忆潜能就能可以得到极大提高</li>
<li>祖先擅长记忆 “东西在哪” “外观如何”</li>
<li>图像记忆与右脑的视觉空间中枢直接相连（例如f-flying = m-mule a-*）</li>
<li>索引卡很有用：正面是索引，背面是具体内容，通过索引联想具体内容，多个卡片可以打乱，交叉记忆</li>
<li>速记卡软件Anki</li>
</ul>
</li>
<li><p>什么是长期记忆（无笔记） </p>
</li>
<li><p>创建有意义的小组和记忆宫殿的技巧（无笔记）<br>  - </p>
</li>
<li>记忆总结<ul>
<li>学会更有原则并不失创造性的使用自己的记忆，这可以帮助集中注意力</li>
<li>长时记忆：像存储仓库，将练习分成几天进行，有利于更好的强化记忆</li>
<li>工作记忆：劣质黑板，上面的字迹难以久留</li>
<li>高度视觉化和空间化的记忆系统：画面生动有趣，看，感受，倾听，嗅觉去体会你要记住的东西，连续数日的重复大有裨益</li>
<li>创造有意义的意群来简化材料 把数字与年份或是其他你熟悉的东西联系起来</li>
<li>宫殿记忆法：把记忆画面放在一个熟悉的场景中，有助于加强可视化记忆系统</li>
<li>提供有效的方式去分类记忆，通过有一的分类和缩写，可以简化并将想要学习的内容组块化</li>
<li>通过背诵你已经理解的材料，可以彻底的消化材料</li>
<li>要巩固你的精神图书馆，你需要真正的掌握材料</li>
</ul>
</li>
</ul>
<h2 id="ORID学习和实践_2018年06月28日">ORID学习和实践 2018年06月28日</h2><h3 id="ORID是什么">ORID是什么</h3><ul>
<li><strong>Objective</strong>：<strong>事实</strong>。 客观事实层次，就是你看到、听到、闻到、尝到、摸到，感触到的一切。</li>
<li><strong>Reflective</strong>：<strong>感受</strong>。 情绪感觉层次，就是你的喜怒哀乐，开心、兴奋、失望、恐惧、难受香菇等等。</li>
<li><strong>Interpretive</strong>：<strong>想法</strong>。 诠释层次， 就是你自己的理解，反思。</li>
<li><strong>Decisional</strong> ： <strong>决定</strong>。 决定层次，就是你接下来的打算</li>
</ul>
<h3 id="ORID有什么用">ORID有什么用</h3><pre><code><span class="title">ORID</span> 以前主要用于会议讨论、培训。通过四个层次循序渐进的提问，引导回答者从事情的表象进行深层次的思    考，并最终作出行为的决策。  Xdite老师说，自从使用了ORID进行每日反思，自己再也不会犯以前那些一犯再犯的错误了，进步神速。
</code></pre><h3 id="模版">模版</h3><p><strong>Objective 客观</strong>：</p>
<ul>
<li>关于今天的课程, 你记得什么?</li>
<li>完成了什么?</li>
</ul>
<p><strong>Reflective 感受</strong></p>
<ul>
<li>你要如何形容今天的情绪</li>
<li>今天的高峰是什么?</li>
<li>今天的低点是什么?</li>
</ul>
<p><strong>Interpretive 解释反思</strong></p>
<ul>
<li>我们今天学到了什么?</li>
<li>今天一个重要的领悟是什么?</li>
</ul>
<p><strong>Decisional 决定行动</strong></p>
<ul>
<li>我们会如何用一句话形容今天的工作</li>
<li>有哪些工作需要明天继续努力?</li>
</ul>
<p>四个层次，层层递进，条理层次。<br> 总的来说，就是<strong>描述：今天学习的状况，分享你的感受，接着反思，解释你学习的内容意义，最后做出决定，明天该如何改进学习。</strong></p>
<h3 id="ORID_升级版">ORID 升级版</h3><p> <strong>Objective</strong> ：全盘式的彻底扫描,</p>
<ul>
<li>有哪些人、事、物</li>
<li>哪些场景让你印象深刻</li>
<li>你观察到什么 ……</li>
</ul>
<p><strong>Reflective</strong> : 从上一层次扫描到的档案，提取自己的想法感受、有趣的，好玩的，怪异的，进一步整理自己的感觉</p>
<ul>
<li>哪些内容什么让你觉得惊讶、意外？有趣好笑？</li>
<li>哪些内容让你感受鼓舞？很受感动？</li>
<li>什么时候让你沮丧？让你特别难过？</li>
<li>你的直觉反应是什么？</li>
<li>你记得事情怎么发生的？</li>
<li>事情发生时你的感想是什么？ ……</li>
</ul>
<p><strong>Interpretive</strong> : 提取我们的感官和反应的——意义和重要性。同时可以提出问题，进一步去思考，进一步获得自己内心深处的观点及想法，尝试从不同的角度看待问题。</p>
<ul>
<li>有什么关键的转折点吗？</li>
<li>自己到底在表达些什么？</li>
<li>得到了什么新的知识？</li>
<li>这里最有意义的是什么？</li>
<li>为什么对我们很重要？</li>
</ul>
<p><strong>Decisional</strong> ——从众多想法萃取出一个结论， 最后呢？所以呢？打算怎么做？可以抛出结论式问题，或给一句话当作结论。促进自己内化或付诸行动。</p>
<ul>
<li>解答在哪里？</li>
<li>明天，你会有什么不同行动？</li>
<li>有什么要改变的？</li>
<li>一句话总结要解决的问题</li>
<li>总结提出的解法是什么</li>
<li>要改变的行动是为了什么</li>
</ul>
<h3 id="实践">实践</h3><p>每天进行ORID讨论，可以自己进行，也可以和麦苗儿妈，麦苗儿一起进行，并记录下来。</p>
<h3 id="效果和体会">效果和体会</h3><h3 id="参考">参考</h3><ol>
<li><a href="https://www.jianshu.com/p/56e5bf8ae9ee" target="_blank" rel="noopener">如何使用ORID总结学习，加快进步</a></li>
</ol>
<h2 id="幽门螺旋杆菌治疗_2016年10月21日">幽门螺旋杆菌治疗 2016年10月21日</h2><h3 id="四联疗法_PPI+抗生素">四联疗法 PPI+抗生素</h3><ol>
<li>阿莫西林 或青霉素类药物</li>
<li>克拉霉素 甲硝唑 或奥硝唑（效果没有甲硝唑理想）（甲硝唑的耐药性很高，最好再加用一个胶体果胶铋）</li>
<li>胶体果胶铋（保护胃黏膜）</li>
<li>奥美拉唑 (PPI,PPI就是质子泵抑制剂，主要用于抑制胃酸分泌的。)</li>
<li>雷贝拉唑钠 （抑酸剂在根除方案中起重要作用:PPI抑酸作用受药物作用强度、宿主参与PPI代谢的CYP2C19基因多态性等影响。选择作用稳定、疗效高、受CYP2C19基因多态性影响较小的PPI,如埃索美拉唑[54]、雷贝拉唑,可提高根除率[55]）<br>(使用前首先排除存在癌症的可能性；服用期间，定期进行血液检查及血液生化学如肝酶检查，发现异常停止用药，及时处理。肝功能损伤者慎用)</li>
</ol>
<ul>
<li><p>早晨餐前<br>一次1粒 1粒20mg 一天1次</p>
</li>
<li><p>餐前：<br>半小时 胶体果胶铋 1-2粒 每粒100mg 一日3次</p>
</li>
<li><p>餐后：<br>半小时 阿莫西林 1-2片 每片375mg，一日3次 （不超过14天）</p>
</li>
<li><p>晚上睡觉前：</p>
<p>奥美拉唑 一片 20mg （排除溃疡性胃癌的可能，因为会减轻其症状，耽误治疗）</p>
<p>克拉霉素分散片 一片250mg 每12小时一次 连续服用 6-14日 </p>
</li>
</ul>
<h3 id="Notice">Notice</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">此外，建议饮食规律、少食多餐；应细嚼慢咽，忌暴饮暴食；避免刺激性食物，忌烟戒酒、少饮浓茶咖啡及进食辛辣、过热和</span><br><span class="line">粗糙食物；胃酸过低和有胆汁反流者，宜多吃瘦肉、禽肉、鱼、奶类等高蛋白低脂肪饮食；避免服用对胃有刺激性的药物</span><br><span class="line">（如水杨酸钠、消炎痛、保泰松和阿斯匹林等）；缓解精神紧张，保持情绪乐观，从而提高免疫功能和增强抗病能力；</span><br><span class="line">注意劳逸结合，适当锻炼身体。</span><br></pre></td></tr></table></figure>
<h3 id="references">references</h3><ol>
<li><a href="http://dxy.com/disease/helicobacter-pylori-infection" target="_blank" rel="noopener">幽门螺杆菌感染</a></li>
</ol>
<h2 id="癌症相关_2013-08-04_12:00:00">癌症相关 2013-08-04 12:00:00</h2><p>updated: 2013-08-04 12:00:00</p>
<hr>
<p>癌症相关的知识。<br><a id="more"></a></p>
<h3 id="饮食注意">饮食注意</h3><p>在美国，每25人中就有1人曾经或者正在患有癌症，不过接近7成的美国癌症患者确诊后都能活过5年。中国的数据不清楚，但是可以肯定的是，癌症病人也不少，确诊的癌症患者存活率很可能低于美国。<br>    一旦确诊癌症，除了接受标准的治疗（比如手术及放化疗）之外，非常多的癌症患者会拼命寻找各种办法，包括饮食、保健品或运动锻炼等办法，希望癌症不会转移复发，希望自己健康，别英年早逝。很多人会有许多疑问，比如：我应该吃些什么？怎么吃？怎么运动锻炼？怎么保持体重？要不要吃保健品？要不要吃中药？估计许多医生也被问及这些问题，但是其实大多数医生（包括肿瘤科医生）并不十分关注，经常随便应付了事。目前也有非常多的对癌症患者的饮食和运动建议（来源自网络、书籍或家人朋友建议），可惜目前绝大多数建议并未被证实有效。<br>    2012年美国医师协会找到了一群营养、运动及肿瘤生存方面的专家，综合评判了几乎所有的可靠的癌症相关的营养运动方面的临床研究，制定了针对癌症患者的营养及运动指南。我认为，这些指南是美国人民无私的拿非常多的资金（保守估计几十亿美元）及人力研究出来的结果，虽然人种不同，但也很有价值，值得学习。<br>    首先，癌症患者必须明白：癌症除了有转移复发的风险，出现心血管疾病、骨质疏松及第二原发癌的风险也增加。合适的运动锻炼、饮食及体重管理可以减轻癌症治疗相关不良反应，改善患者生理功能、减轻乏力并改善生活质量，最重要的是，可以显著减少肿瘤的转移复发，尤其是在乳腺癌及肠癌患者，甚至可能减少高达40-50%的死亡风险。因此非常重要。  </p>
<p>具体措施：  </p>
<ol>
<li>肿瘤患者的运动锻炼<br>已经至少有20篇以上的前瞻观察性研究已经显示运动锻炼的患者有更低的肿瘤复发风险，目前的证据鼓励患者尽可能早的进行安全的运动锻炼，可以增加骨骼健康、肌肉强度，减少心血管疾病及骨质疏松风险，减少第二原发癌风险，即使在化疗及放疗过程中也可以依据体力状况进行低至中等强度的运动锻炼。<br>运动方式如下：参考ACSM(美国运动医学联盟)2008年制定的美国运动指南，该指南建议患者必须并且尽快进行正常的运动锻炼：19到64岁之间的患者应至少每周进行150分钟以上的中等强度运动或者75分钟以上的高强度有氧运动，或是两者结合。每次运动持续的时间至少10分钟以上，最好持续于整周。成人应该进行力量训练，尽量包括所有主要的肌肉，每周至少2天。65岁以上的人群如果有能力也尽量遵循上述方式，如果慢性疾病限制运动，可以自行调整。<br>什么是中等强度运动及高强度运动？<br>中等强度运动（运动期间可以讲话，不能唱歌）：在平地或者轻度倾斜的地面骑自行车，松土和修剪树木等园艺工作，少跑动的玩篮球、排球等，双打网球，快步走路，跳舞，水中的有氧运动等。<br>高强度运动 (运动期间只能说几个简单的字)：有氧运动舞蹈，骑车速度超过16公里/小时，快速跳舞，重度的体力运动（挖土和掘土），骑车上山，跳绳，空手道等，竞走、慢跑和快跑， 跑动很多的玩篮球或足球，快速游泳，单打网球。  </li>
</ol>
<p>2．饮食<br>AHA（美国心脏病协会）推荐了成人的营养构成食谱：脂肪：25-35%的热量，碳水化合物50-60%，蛋白10-35%的热量，最少0.8g/KG。<br>我推荐患者饮食如下：<br>    禁止吸烟，限制饮酒。<br>    低脂饮食：少吃油炸食品及油腻的食物。<br>    少吃红肉：红肉主要是指猪肉及牛羊肉。<br>    推荐富含omega-3脂肪酸的食物(比如鱼和坚果)。<br>    推荐瘦肉、不带皮的家禽，蛋类，无脂或低脂牛奶产品，坚果，种子及豆类。<br>    推荐全谷物饮食：富含多种复合物及抗氧化物，具有激素及抗氧化作用，影响脂类代谢，减少肿瘤发生及进展的风险，减少心血管疾病的风险。<br>    推荐蔬菜及水果：蔬菜和水果含有很多营养成分有可能抑制肿瘤进展，例如必要的维生素及微量元素，生物植物化学成分及纤维。蔬菜水果含有热量较低，多食用有助于控制体重。推荐纯天然果汁及十字花科的蔬菜。<br>    高糖饮食并不会增加肿瘤发生及进展。但是过多食用会引起其它营养元素摄入减少并引起体重增加。因此，建议限制使用含有过多糖的食物。<br>    饮食补充剂(或称为保健品)：包括各种维生素、微量元素、草药/植物、氨基酸等。比如：叶酸、硒、维生素C。必须谨慎使用，在使用之前，最好检测是否缺乏，一般的癌症患者并不建议使用饮食补充剂，尽量从食物中获取各种营养。<br>    总结：禁烟限酒，推荐低脂、高蛋白及高蔬菜水果饮食，推荐全谷物饮食，推荐多食用鱼类及坚果，不建议食用过多的高糖、高脂及红肉。推荐植物油，不推荐动物油。保健品及中药需要非常谨慎的使用。  </p>
<p>3.体重管理<br>达到及维持健康的体重是主要的目标。<br>健康体重，定义为BMI 18.5kg/m2至25Kg/m2。BMI定义：身高(公斤)除以体重（米）的平方。<br>    建议患者每周测2次空腹时体重，即晨起后的体重，并计算BMI指数，然后调整饮食和运动量。   </p>
<p>四、其它注意事项：  </p>
<ol>
<li>癌症患者的家庭成员也有较高的风险患有肿瘤，也鼓励遵从ACS的营养及运动指南，以预防癌症。  </li>
<li>严重疲乏的时候不适合运动，体重进行性下降时不适合高强度运动。  </li>
<li>活动障碍的患者，低强度的活动比较合适，比如伸展动作和缓慢的行走，并可缓慢增加强度。对于老年患者或是存在骨转移、骨质疏松、严重的关节炎及外周神经疾病的患者，必须更加小心注意平衡及安全  </li>
<li>严重的贫血时患者应推迟锻炼，仅仅做些日常生活中的活动，直至贫血改善。  </li>
<li>存在免疫缺陷时应当避免去健身馆或是公共泳池，直到白细胞计数恢复正常范围。完成骨髓移植的患者不应暴露于公众人群，至少要移植1年以后开始。  </li>
<li>放疗过程中应当避免接触氯，比如禁止在游泳池游泳。  </li>
<li>置有体内导管和营养管时应当不接触池塘、湖水及海水或其他有细菌的物质，以避免感染，导管相关肌肉应当避免抗阻力运动及剧烈运动，以免导管脱出。  </li>
<li>合并多种或未受控制的并发症时，建议咨询医生后进行运动锻炼。 </li>
</ol>
<h3 id="XELOX方案">XELOX方案</h3><p>1、 给药方案及时间安排：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">奥沙利铂： 静脉滴注3小时，第1天；</span><br><span class="line"></span><br><span class="line">卡培他滨： 口服，2次/天，第1~14天；</span><br><span class="line"></span><br><span class="line">上述方案每3周重复1次。</span><br></pre></td></tr></table></figure>
<p>2、 住出院程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">患者以上一次化疗开始日期为准，向后推移3周，即为初步估计的下次化疗开始日期。在此日期之前4天，门诊就诊复查血常规，将化验结果送返病房，预约住院。病房医师会尽量为您按时安排入院化疗。</span><br><span class="line"></span><br><span class="line">入院后当天，患者应空腹办理住院手续。入院后再次复查血常规及肝肾功能，若结果均正常，于住院当天下午可行化疗治疗。化疗第1天应严格遵守住院观察原则，不得请假回家。若患者无明显不适症状，可于第2日办理出院手续。因卡培他滨不良反应极小，患者可在家中服用。</span><br><span class="line"></span><br><span class="line">若患者入院当天血液检查结果明显异常，如白细胞明显下降或转氨酶升高，则需要行升白治疗或保肝治疗。待治疗后复查白细胞和肝功能，结果回报正常后，方开始本次化疗。</span><br></pre></td></tr></table></figure>
<p>3、 院外注意事项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">由于奥沙利铂报告的不良反应多有骨髓抑制、消化道反应、神经毒性反应，卡培他滨不良反应多为消化道症状及皮肤症状，故患者化疗间期在院外应密切关注病情变化，如有异常，及时就医。</span><br><span class="line"></span><br><span class="line">a) 骨髓抑制：患者化疗间期时应密切关注白细胞波动情况。建议患者出院后每隔3~4日复查血常规，若发现白细胞低于4.0X109/L，或中心粒细胞低于1.5X109/L，应及时就诊，给予升白治疗。同时避免接触公共场所，以免发生严重全身感染。</span><br><span class="line"></span><br><span class="line">b) 胃肠道反应：患者化疗期间可能出现恶心、呕吐等胃肠道反应，因此化疗间期建议患者饮食规律、清淡，以防出现恶心、呕吐等不适症状。若出现严重呕吐症状应及时就诊予补液治疗。</span><br><span class="line"></span><br><span class="line">c) 神经毒性反应：主要表现为肢体末端感觉障碍或/和感觉异常。伴或不伴有痛性痉挛，通常此症状遇冷会激发。据报告，奥沙利铂所致的神经毒性发生率达85-95%。在治疗间歇期，症状通常会减轻，但随着治疗周期的增加，症状也会逐渐加重。若患者症状严重，且持续时间较长，应在下一次化疗时报告医师。医师会通过患者的具体情况，决定减量或暂停使用奥沙利铂。</span><br><span class="line"></span><br><span class="line">d) 皮肤症状：约半数患者在服药期间出现皮肤症状，如麻木、感觉迟钝、感觉异常、麻刺感、无痛感或疼痛感，皮肤肿胀或红斑，脱屑、水泡或严重的疼痛。轻度不适患者可不予处理，但若患者皮肤严重，应在下一次化疗时报告医师。医师会通过患者的具体情况，决定是否暂时停用卡培他滨。</span><br></pre></td></tr></table></figure>
<h3 id="参考-1">参考</h3><ol>
<li><a href="http://suxiangqian.54doctor.net/_PatientArea/Index.htm" target="_blank" rel="noopener">北京肿瘤医院苏向前</a></li>
<li><a href="http://www.bjcancer.org/_Video/View.aspx?id=4024" target="_blank" rel="noopener">肠癌</a></li>
<li><a href="http://www.bjguahao.gov.cn/comm/yyks.php?hpid=17" target="_blank" rel="noopener">挂号网站</a></li>
<li><a href="http://www.newsmth.net/nForum/#!article/Medicine/116392" target="_blank" rel="noopener">水木咨询</a></li>
</ol>
<h2 id="健康相关">健康相关</h2><p>看完吴清忠（《人体使用手册》作者）和梁冬（可搜索腾讯视频）的对话节目，有几点感受：</p>
<ol>
<li>晚睡导致肝火旺，失眠就是睡觉晚导致的，睡觉晚导致肝火旺，互为因果，因此治疗失眠早睡即可，妈妈应该有体会。</li>
<li>慢性病都是长期生活习惯积累而成，得病的时候，身体的趋势是螺旋下降的，而养病的时候，需要做的是不断改善自己的习惯，调整自己的饮食和睡眠等等。</li>
<li>养病的时候，先提高自己的某一个器官，比如肾脏，然后再拉升水平最低的那个器官，所以生病一月，养病一年。（其实这个类比到处理人与人的关系，人与职业的关系，甚至投资理财都是这个道理）</li>
<li>有时候生小病是好事，解释是这样的：有时候我们没有能力去生病了，比如八个人吃东西，七个人肠胃都拉了，一个人不拉，不是这个人身体好，而是那个人没有能力生病了。<br>这让我想到，幸福的反面不是痛苦，而是冷漠，我们能感受幸福说明很好，当我们对事情都没有兴趣，失去了心力，冷漠麻木的时候，我们的精神就生病了，需要慢慢养，改善自己的环境，调整自己的习惯，坚持下来，短时间不一定有效果，但长期下来就会发现进步很多了。</li>
<li>春天会有过敏性鼻炎，春天是治不好的，只有在下一个冬天注意保暖，才能治好。因为生病是有一定的时间长度的。</li>
</ol>
<p>2019-04-12<br>吴清忠：长寿时代，健康快乐活到老</p>
<ol>
<li>慢性病是一种生意，疾病不是这样治疗的，慢性病终身服药只是药厂的目标。</li>
<li>现代医学的问题：慢性病一直没有解决</li>
<li>痛风的解决：痛风是尿酸结晶，固体导致的。方法是：先把结晶变成液体（水肿），再把水排掉即可（这个药将时间减少到一天，不然自愈的情况就是需要躺几天，现在的问题是药把水排掉，结晶留下了，就会留下很大的结晶。这种治疗的真正意义是创造更多的治疗。问题是：水肿的意义：就是身体自愈的过程，需要产生水肿再将结晶清除掉，比如虾不让吃，也有可能这个虾才是治愈你疾病的药）</li>
<li>从人体设计者的角度考虑问题（中医速度）,中医是治因不治果，人的生病一般是生活方式的问题，所以治疗方法一定是简单的（这点我认同，需要找到问题的原因，从根处解决）。</li>
<li>养生：就是进行自愈</li>
<li>很多药都是 阻止身体的自愈过程，所以这些药都是不对的。比如打喷嚏是身体自愈：排除寒气，而吃药就是不让人打喷嚏，而寒气就会留下来。</li>
<li>年轻人就要开始规划自己的退休时间。我们学习二十年为了三十年的工作，而我们退休后的时间呢？活到90岁，60岁眼睛就坏了，所以年轻时候就要注意身体，为退休人生的第二段生命做准备。</li>
<li>出院：是因为你对医院的贡献比较小，而不是因为你康复了。</li>
<li>古代人生病的问题：食物问题。我们现代人生病的问题：作息生活发生了改变，不睡觉的病：只有通过睡觉才能补回来。</li>
<li>根本解决疾病的方法：从人体设计的角度出发，怎么设计自己的身体，才能保证身体的健康。</li>
<li>中医最大的贡献：对器官的分类：有经络和无经络的器官。为什么没有一个经络是和大脑有关，因为大脑是最重要的器官，身体的维修：内部维修，经络就是用于内部维修的，没有经络的器官说明那个器官会生病，但不是那个器官的原因，病因一定在有经络的器官。比如：眼睛没有经络，而通过眼睛的有两条经络：小肠经，膀胱经，近视眼、黄斑脱落等就是前面的供给不够：小肠经的问题，青光眼则是内部的垃圾排不出去，膀胱经的问题。感冒：大便就不通，如果大便通了，说明到感冒末期了，大肠和肺是一起变化的。</li>
<li>经络是治疗脏腑的通道。</li>
<li>身体诊断：中医很简单，有两个指标：经络的平衡，有经络诊断仪器已基本研发出来。</li>
<li>（三招：睡眠，敲胆经，按摩心包经。造血：睡觉+敲胆经），睡眠非常重要。近视眼和心脏有关。血氧充足才能启动修复机制。<br>推荐书目：洛克菲洛医学：讲医学发展的历史</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
            <category> 学习笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
